<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RANSAC算法</title>
      <link href="/2023/01/22/RANSAC%E7%AE%97%E6%B3%95/"/>
      <url>/2023/01/22/RANSAC%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="RANSAC算法"><a href="#RANSAC算法" class="headerlink" title="RANSAC算法"></a>RANSAC算法</h3><hr><p><strong>RANSAC</strong>(<strong>RA</strong>ndom <strong>SA</strong>mple <strong>C</strong>onsensus,随机采样一致)算法</p><hr><p><strong>RANSAC</strong>(<strong>RA</strong>ndom <strong>SA</strong>mple <strong>C</strong>onsensus,随机采样一致)算法是从一组含有“外点”(outliers)的数据中正确估计数学模型参数的迭代算法。“外点”一般指的的数据中的噪声，比如说匹配中的误匹配和估计曲线中的离群点。所以，RANSAC也是一种“外点”检测算法。RANSAC算法是一种不确定算法，它只能在一种概率下产生结果，并且这个概率会随着迭代次数的增加而加大（之后会解释为什么这个算法是这样的）。RANSAC算最早是由Fischler和Bolles在SRI上提出用来解决LDP(Location Determination Proble)问题的。</p><p>对于RANSAC算法来说一个<strong>基本的假设</strong>就是数据是由“内点”和“外点”组成的。“内点”就是组成模型参数的数据，“外点”就是不适合模型的数据。同时RANSAC假设：在给定一组含有少部分“内点”的数据，存在一个程序可以估计出符合“内点”的模型。</p><h4 id="算法基本思想和流程"><a href="#算法基本思想和流程" class="headerlink" title="算法基本思想和流程"></a>算法基本思想和流程</h4><p>RANSAC是通过反复选择数据集去估计出模型，一直迭代到估计出认为比较好的模型。<br>具体的实现步骤可以分为以下几步：</p><ol><li>选择出可以估计出模型的最小数据集；(对于直线拟合来说就是两个点，对于计算Homography矩阵就是4个点)</li><li>使用这个数据集来计算出数据模型；</li><li>将所有数据带入这个模型，计算出“内点”的数目；(累加在一定误差范围内的适合当前迭代推出模型的数据)</li><li>比较当前模型和之前推出的最好的模型的“内点“的数量，记录最大“内点”数的模型参数和“内点”数；</li><li>重复1-4步，直到迭代结束或者当前模型已经足够好了(“内点数目大于一定数量”)。</li></ol><h4 id="迭代次数推导"><a href="#迭代次数推导" class="headerlink" title="迭代次数推导"></a>迭代次数推导</h4><p>假设“内点”在数据中的占比为 <img src="https://www.zhihu.com/equation?tex=t" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=t=%5Cfrac%7Bn_%7Bi+n+l+i+e+r+s%7D%7D%7Bn_%7Bi+n+l+i+e+r+s%7D+n_%7Bo+u+t+l+i+e+r+s%7D%7D+%5C%5C" alt="[公式]"></p><p>那么我们每次计算模型使用 <img src="https://www.zhihu.com/equation?tex=N" alt="[公式]"> 个点的情况下，选取的点至少有一个外点的情况就是</p><p><img src="https://www.zhihu.com/equation?tex=+1+-+t%5EN+%5C%5C" alt="[公式]"></p><p>也就是说，在迭代 <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]"> 次的情况下， <img src="https://www.zhihu.com/equation?tex=(1-t_n)%5Ek" alt="[公式]"> 就是 <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]"> 次迭代计算模型都至少采样到一个“外点”去计算模型的概率。那么能采样到正确的 <img src="https://www.zhihu.com/equation?tex=N" alt="[公式]"> 个点去计算出正确模型的概率就是</p><p><img src="https://www.zhihu.com/equation?tex=P=1-%5Cleft(1-t%5E%7Bn%7D%5Cright)%5E%7Bk%7D+%5C%5C" alt="[公式]"></p><p>通过上式，可以求得</p><p><img src="https://www.zhihu.com/equation?tex=k=%5Cfrac%7B%5Clog+(1-P)%7D%7B%5Clog+%5Cleft(1-t%5E%7Bn%7D%5Cright)%7D++%5C%5C" alt="[公式]"></p><p>内点”的概率 <img src="https://www.zhihu.com/equation?tex=t" alt="[公式]"> 通常是一个先验值。然后 <img src="https://www.zhihu.com/equation?tex=P" alt="[公式]"> 是我们希望RANSAC得到正确模型的概率。如果事先不知道 <img src="https://www.zhihu.com/equation?tex=t" alt="[公式]"> 的值，可以使用自适应迭代次数的方法。也就是一开始设定一个无穷大的迭代次数，然后每次更新模型参数估计的时候，用当前的“内点”比值当成 <img src="https://www.zhihu.com/equation?tex=t" alt="[公式]"> 来估算出迭代次数。</p><h5 id="用Python实现直线拟合"><a href="#用Python实现直线拟合" class="headerlink" title="用Python实现直线拟合"></a>用Python实现直线拟合</h5><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> random<span class="token keyword">import</span> math<span class="token comment" spellcheck="true"># 数据量。</span>SIZE <span class="token operator">=</span> <span class="token number">50</span><span class="token comment" spellcheck="true"># 产生数据。np.linspace 返回一个一维数组，SIZE指定数组长度。</span><span class="token comment" spellcheck="true"># 数组最小值是0，最大值是10。所有元素间隔相等。</span>X <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> SIZE<span class="token punctuation">)</span>Y <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> X <span class="token operator">+</span> <span class="token number">10</span>fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 画图区域分成1行1列。选择第一块区域。</span>ax1 <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 标题</span>ax1<span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">"RANSAC"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 让散点图的数据更加随机并且添加一些噪声。</span>random_x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>random_y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 添加直线随机噪声</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>SIZE<span class="token punctuation">)</span><span class="token punctuation">:</span>    random_x<span class="token punctuation">.</span>append<span class="token punctuation">(</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     random_y<span class="token punctuation">.</span>append<span class="token punctuation">(</span>Y<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 添加随机噪声</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>SIZE<span class="token punctuation">)</span><span class="token punctuation">:</span>    random_x<span class="token punctuation">.</span>append<span class="token punctuation">(</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    random_y<span class="token punctuation">.</span>append<span class="token punctuation">(</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">)</span>RANDOM_X <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>random_x<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 散点图的横轴。</span>RANDOM_Y <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>random_y<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 散点图的纵轴。</span><span class="token comment" spellcheck="true"># 画散点图。</span>ax1<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>RANDOM_X<span class="token punctuation">,</span> RANDOM_Y<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 横轴名称。</span>ax1<span class="token punctuation">.</span>set_xlabel<span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 纵轴名称。</span>ax1<span class="token punctuation">.</span>set_ylabel<span class="token punctuation">(</span><span class="token string">"y"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用RANSAC算法估算模型</span><span class="token comment" spellcheck="true"># 迭代最大次数，每次得到更好的估计会优化iters的数值</span>iters <span class="token operator">=</span> <span class="token number">100000</span><span class="token comment" spellcheck="true"># 数据和模型之间可接受的差值</span>sigma <span class="token operator">=</span> <span class="token number">0.25</span><span class="token comment" spellcheck="true"># 最好模型的参数估计和内点数目</span>best_a <span class="token operator">=</span> <span class="token number">0</span>best_b <span class="token operator">=</span> <span class="token number">0</span>pretotal <span class="token operator">=</span> <span class="token number">0</span><span class="token comment" spellcheck="true"># 希望的得到正确模型的概率</span>P <span class="token operator">=</span> <span class="token number">0.99</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>iters<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 随机在数据中红选出两个点去求解模型</span>    sample_index <span class="token operator">=</span> random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>range<span class="token punctuation">(</span>SIZE <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>    x_1 <span class="token operator">=</span> RANDOM_X<span class="token punctuation">[</span>sample_index<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    x_2 <span class="token operator">=</span> RANDOM_X<span class="token punctuation">[</span>sample_index<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    y_1 <span class="token operator">=</span> RANDOM_Y<span class="token punctuation">[</span>sample_index<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    y_2 <span class="token operator">=</span> RANDOM_Y<span class="token punctuation">[</span>sample_index<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># y = ax + b 求解出a，b</span>    a <span class="token operator">=</span> <span class="token punctuation">(</span>y_2 <span class="token operator">-</span> y_1<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>x_2 <span class="token operator">-</span> x_1<span class="token punctuation">)</span>    b <span class="token operator">=</span> y_1 <span class="token operator">-</span> a <span class="token operator">*</span> x_1    <span class="token comment" spellcheck="true"># 算出内点数目</span>    total_inlier <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> index <span class="token keyword">in</span> range<span class="token punctuation">(</span>SIZE <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        y_estimate <span class="token operator">=</span> a <span class="token operator">*</span> RANDOM_X<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">+</span> b        <span class="token keyword">if</span> abs<span class="token punctuation">(</span>y_estimate <span class="token operator">-</span> RANDOM_Y<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> sigma<span class="token punctuation">:</span>            total_inlier <span class="token operator">=</span> total_inlier <span class="token operator">+</span> <span class="token number">1</span>    <span class="token comment" spellcheck="true"># 判断当前的模型是否比之前估算的模型好</span>    <span class="token keyword">if</span> total_inlier <span class="token operator">></span> pretotal<span class="token punctuation">:</span>        iters <span class="token operator">=</span> math<span class="token punctuation">.</span>log<span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> P<span class="token punctuation">)</span> <span class="token operator">/</span> math<span class="token punctuation">.</span>log<span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> pow<span class="token punctuation">(</span>total_inlier <span class="token operator">/</span> <span class="token punctuation">(</span>SIZE <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        pretotal <span class="token operator">=</span> total_inlier        best_a <span class="token operator">=</span> a        best_b <span class="token operator">=</span> b    <span class="token comment" spellcheck="true"># 判断是否当前模型已经符合超过一半的点</span>    <span class="token keyword">if</span> total_inlier <span class="token operator">></span> SIZE<span class="token punctuation">:</span>        <span class="token keyword">break</span><span class="token comment" spellcheck="true"># 用我们得到的最佳估计画图</span>Y <span class="token operator">=</span> best_a <span class="token operator">*</span> RANDOM_X <span class="token operator">+</span> best_b<span class="token comment" spellcheck="true"># 直线图</span>ax1<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>RANDOM_X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span>text <span class="token operator">=</span> <span class="token string">"best_a = "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>best_a<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\nbest_b = "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>best_b<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span> text<span class="token punctuation">,</span>         fontdict<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'size'</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">'color'</span><span class="token punctuation">:</span> <span class="token string">'r'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="D:\HEXO\source\images\image-20220718002303153.png" alt="image-20220718002303153"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年工作暂时性总结</title>
      <link href="/2023/01/22/2022%E5%B9%B4%E5%B7%A5%E4%BD%9C%E6%9A%82%E6%97%B6%E6%80%A7%E6%80%BB%E7%BB%93/"/>
      <url>/2023/01/22/2022%E5%B9%B4%E5%B7%A5%E4%BD%9C%E6%9A%82%E6%97%B6%E6%80%A7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="2022年工作暂时性总结"><a href="#2022年工作暂时性总结" class="headerlink" title="2022年工作暂时性总结"></a>2022年工作暂时性总结</h3><h4 id="1-车路协同目标检测项目"><a href="#1-车路协同目标检测项目" class="headerlink" title="1. 车路协同目标检测项目"></a>1. 车路协同目标检测项目</h4><p>参与车路协同 目标检测项目中的开发支持，人机非等指标达到项目要求</p><h4 id="2-多目融合代码开发"><a href="#2-多目融合代码开发" class="headerlink" title="2.多目融合代码开发"></a>2.多目融合代码开发</h4><p>实现多相机目标融合， 相机切换利用位置进行轨迹平滑， 利用瞩目目标过来了雷视徐建目标，确保无重复id输出，以下沙的数据为例子， 标注了一个融合的数据集</p><h4 id="3-路侧停车泊位划线"><a href="#3-路侧停车泊位划线" class="headerlink" title="3. 路侧停车泊位划线"></a>3. 路侧停车泊位划线</h4><p>支持3559a,3519a,ax630 ax620a,sd3403等平台，发测指标P90+ R 90+</p><h4 id="4-全图目标定位和朝向"><a href="#4-全图目标定位和朝向" class="headerlink" title="4.全图目标定位和朝向"></a>4.全图目标定位和朝向</h4><p>朝向：有限的数据集标注(2-3w)，目标高大于1/30，朝向角度误差11°以内，正确率为88.5%，且检测指标浮动在2%以内</p><p>定位：在nx平台上工程化实现，工程耗时由86ms减少到19ms， 指标差异不大，在车顶点、路侧停车数据集以及贴地点伪标签数据上探索了定位不同的实现方式，验证哪些是可行的哪些对参数依赖比较大，减少对人为设定参数的依赖。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20220612讨论</title>
      <link href="/2023/01/22/20220612/"/>
      <url>/2023/01/22/20220612/</url>
      
        <content type="html"><![CDATA[<h3 id="20220612"><a href="#20220612" class="headerlink" title="20220612"></a>20220612</h3><h4 id="用docker例子"><a href="#用docker例子" class="headerlink" title="用docker例子"></a>用docker例子</h4><ul><li>怎么把你的image构建的很好</li><li>容量小，并且满足大部分的应用</li><li>shm怎么配置</li><li>dockrfile怎么写</li><li>挂载怎么做</li><li>gpu怎么选卡</li><li>怎么在容器里联调， 容器出了问题怎么解决</li><li>应用在k8s上有啥问题，需要怎么优化。</li></ul><blockquote><p>每个点都有深度可以做，依据自己的怪话，选择自己的切入点</p></blockquote><h4 id="假如模型都是过拟合，怎么定位这个问题"><a href="#假如模型都是过拟合，怎么定位这个问题" class="headerlink" title="假如模型都是过拟合，怎么定位这个问题"></a>假如模型都是过拟合，怎么定位这个问题</h4><ul><li>请问怎么知道它过拟合的类型</li><li>因为什么过拟合的</li><li>模型原因还是数据原因</li><li>训练策略原因</li><li>还是说提前没有预热</li></ul><blockquote><p>花点时间研究比较底层的东西， 别人为什么这么设计算法</p></blockquote><h4 id="本质例如多类分类多标签分类分割，这些他们的本质是在做什么事"><a href="#本质例如多类分类多标签分类分割，这些他们的本质是在做什么事" class="headerlink" title="本质例如多类分类多标签分类分割，这些他们的本质是在做什么事"></a>本质例如多类分类多标签分类分割，这些他们的本质是在做什么事</h4><ul><li>凸优化大概的一个原理</li><li>最优化函数的一个原理</li><li>最小二乘，偏最小2乘等等一系列的</li></ul><h4 id="找到自己擅长的点。"><a href="#找到自己擅长的点。" class="headerlink" title="找到自己擅长的点。"></a>找到自己擅长的点。</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 研讨 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell学习</title>
      <link href="/2023/01/22/shell%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/01/22/shell%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="shell学习"><a href="#shell学习" class="headerlink" title="shell学习"></a>shell学习</h2><h3 id="1-shell概述"><a href="#1-shell概述" class="headerlink" title="1. shell概述"></a>1. shell概述</h3><p>Shell 是一个命令解释器， 用于接收应用程序/用户命令， 然后调用操作系统内核。</p><p><img src="D:\HEXO\source\images\image-20220710001433868.png" alt="image-20220710001433868"></p><p> shell 还是一个功能相当强大的编程语言， 易编写，易调试，灵活性强。</p><h3 id="2-shell解析器"><a href="#2-shell解析器" class="headerlink" title="2. shell解析器"></a>2. shell解析器</h3><pre class=" language-sh"><code class="language-sh">/bin/sh/bin/bash/usr/bin/bash/bin/rbash/usr/bin/rbash/usr/bin/sh/bin/dash/usr/bin/dash</code></pre><pre class=" language-shel"><code class="language-shel">root@2a63e139ac66:/bin# echo $SHELL/bin/bash</code></pre><p>系统默认的是bash</p><h3 id="3-Shell-脚本入门"><a href="#3-Shell-脚本入门" class="headerlink" title="3. Shell 脚本入门"></a>3. Shell 脚本入门</h3><h4 id="3-1-脚本格式"><a href="#3-1-脚本格式" class="headerlink" title="3.1 脚本格式"></a>3.1 脚本格式</h4><p>脚本以#!/bin/bash 开头（指定解析器） </p><h4 id="3-2-第一个shell脚本：-helloworld"><a href="#3-2-第一个shell脚本：-helloworld" class="headerlink" title="3.2 第一个shell脚本： helloworld"></a>3.2 第一个shell脚本： helloworld</h4><h5 id="3-2-1-需求：-创建一个shell脚本，-输出helloworld"><a href="#3-2-1-需求：-创建一个shell脚本，-输出helloworld" class="headerlink" title="3.2.1 需求： 创建一个shell脚本， 输出helloworld"></a>3.2.1 需求： 创建一个shell脚本， 输出helloworld</h5><pre class=" language-shell"><code class="language-shell">#!/bin/bashecho "helloworld shell"</code></pre><pre class=" language-sh"><code class="language-sh"> cd shelldata# ls# pwd/root/shelldata# touch helloworld.sh# vim helloworld.sh### sh helloworld.shhelloworld shell</code></pre><p>权限不够</p><pre><code># ./ helloworld.sh/bin/sh: 33: ./: Permission denied</code></pre><h5 id="3-2-2-脚本的常用执行方式"><a href="#3-2-2-脚本的常用执行方式" class="headerlink" title="3.2.2 脚本的常用执行方式"></a>3.2.2 脚本的常用执行方式</h5><p>第一种： 采用bash或者sh+脚本的相对路径或者绝对路径（不用赋予脚本+x权限）</p><p>第二种： 采用输入脚本的绝对路径或者相对路径执行脚本（必须具有可执行权限+x）</p><blockquote><p>注意： 第一种执行方法， 本质是bash解析器帮你执行脚本， 所以脚本本身不需要执行权限， 第二种执行方法， 本质是脚本自己执行，所以需要执行权限。</p></blockquote><h4 id="3-3-第二个shell脚本：-多命令处理"><a href="#3-3-第二个shell脚本：-多命令处理" class="headerlink" title="3.3 第二个shell脚本： 多命令处理"></a>3.3 第二个shell脚本： 多命令处理</h4><h5 id="3-3-1-需求："><a href="#3-3-1-需求：" class="headerlink" title="3.3.1 需求："></a>3.3.1 需求：</h5><p>在/home/atguigu/目录下创建一个bangzhang.txt, 在banzhang.txt中增加“I Love  cls”</p><h5 id="3-3-2-案例实操"><a href="#3-3-2-案例实操" class="headerlink" title="3.3.2 案例实操"></a>3.3.2 案例实操</h5><pre class=" language-shell"><code class="language-shell">#!/bin/bashcd /root/shelldata/touch banzhang.txtecho "I Love cls">> banzhang.txt</code></pre><p>结果显示</p><pre class=" language-shell"><code class="language-shell">sh-5.1# cat banzhang.txtI Love clsI Love clssh-5.1# rm banzhang.txtsh-5.1# bash hadoop101.shsh-5.1# cat banzhang.txtI Love clssh-5.1# vim hadoop101.sh</code></pre><h3 id="4-Shell中的变量"><a href="#4-Shell中的变量" class="headerlink" title="4. Shell中的变量"></a>4. Shell中的变量</h3><h4 id="4-1-系统变量"><a href="#4-1-系统变量" class="headerlink" title="4.1 系统变量"></a>4.1 系统变量</h4><h5 id="4-1-1-常用系统变量"><a href="#4-1-1-常用系统变量" class="headerlink" title="4.1.1 常用系统变量"></a>4.1.1 常用系统变量</h5><p>$HOME、$PWD、$SHELL、$USER等</p><h5 id="4-1-2-案例实操"><a href="#4-1-2-案例实操" class="headerlink" title="4.1.2 案例实操"></a>4.1.2 案例实操</h5><p>查看系统变量的值</p><pre class=" language-shell"><code class="language-shell">sh-5.1# echo $HOME/rootsh-5.1# echo $PWD/root/shelldatash-5.1#</code></pre><p>显示当前shell中所有变量</p><pre class=" language-shell"><code class="language-shell">BASH=/bin/shBASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:extquote:force_fignore:globasciiranges:hostcomplete:interactive_comments:progcomp:promptvars:sourcepathBASH_ALIASES=()BASH_ARGC=()BASH_ARGV=()BASH_CMDS=()BASH_LINENO=()BASH_SOURCE=()BASH_VERSINFO=([0]="5" [1]="1" [2]="16" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")BASH_VERSION='5.1.16(1)-release'COLUMNS=177DIRSTACK=()EUID=0GROUPS=()HISTFILE=/root/.bash_historyHISTFILESIZE=500HISTSIZE=500HOME=/rootHOSTNAME=8b25e507bccaHOSTTYPE=x86_64IFS=''LINES=50MACHTYPE=x86_64-pc-linux-gnuMAILCHECK=60OLDPWD=/rootOPTERR=1OPTIND=1OSTYPE=linux-gnuPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binPIPESTATUS=([0]="0")POSIXLY_CORRECT=yPPID=0PS1='\s-\v\$ 'PS2='> 'PS4='+ 'PWD=/root/shelldataSHELL=/bin/bashSHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor:posixSHLVL=1TERM=xtermUID=0_=/root/shelldata</code></pre><h4 id="4-2-自定义变量"><a href="#4-2-自定义变量" class="headerlink" title="4.2 自定义变量"></a>4.2 自定义变量</h4><h5 id="4-2-1-基本语法"><a href="#4-2-1-基本语法" class="headerlink" title="4.2.1 基本语法"></a>4.2.1 基本语法</h5><p>定义变量： 变量=值</p><pre class=" language-shell"><code class="language-shell">sh-5.1# A=1sh-5.1# echo AAsh-5.1# echo $A1</code></pre><p>撤销变量： unset变量</p><pre class=" language-shell"><code class="language-shell">sh-5.1# unset Ash-5.1# echo $Ash-5.1#</code></pre><p>声明一个静态变量： readonly变量， 注意：不能unset</p><pre class=" language-shell"><code class="language-shell">sh-5.1# readonly B=3sh-5.1# echo $B3sh-5.1# unset Bsh: unset: B: cannot unset: readonly variablesh-5.1#</code></pre><h5 id="4-2-2-变量定义规则"><a href="#4-2-2-变量定义规则" class="headerlink" title="4.2.2 变量定义规则"></a>4.2.2 变量定义规则</h5><ol><li>变量名称可以由字母、数字和下划线构成， 但是不能以数字开头， 环境变量名建议大写</li><li>等号两侧不能有空格</li><li>在bash中， 变量默认类型都是字符串类型， 无法直接进行数值运算。</li></ol><pre class=" language-shell"><code class="language-shell">sh-5.1# C=1+1sh-5.1#Display all 505 possibilities? (y or n)sh-5.1# echo $C1+1sh-5.1#</code></pre><ol start="4"><li>变量的值如果有空格，需要用双引号或者单引号括起来。</li></ol><pre class=" language-shell"><code class="language-shell">sh-5.1# D=bangzhang love mmsh: love: command not foundsh-5.1# D='bangzhang love mm'sh-5.1# echo $Dbangzhang love mmsh-5.1#</code></pre><ol start="5"><li>可以把变量提升为全局环境变量， 可供其他shell程序使用</li></ol><p>export 变量名</p><pre class=" language-shell"><code class="language-shell">sh: ./helloworld.sh: Permission deniedsh-5.1# chmod +x helloworld.shsh-5.1# ./helloworld.shhelloworld shellsh-5.1# export Dsh-5.1# ./helloworld.shhelloworld shellbangzhang love mm</code></pre><h4 id="4-3-特殊变量：-n"><a href="#4-3-特殊变量：-n" class="headerlink" title="4.3 特殊变量：$n"></a>4.3 特殊变量：$n</h4><h5 id="4-3-1-基本语法"><a href="#4-3-1-基本语法" class="headerlink" title="4.3.1 基本语法"></a>4.3.1 基本语法</h5><p>$n（功能描述：n为数字，$0代表该脚本名称，$1-$9代表第一到第九个参数， 十以上的参数需用大括号包含，如${10}）</p><h5 id="4-3-2-案例实操"><a href="#4-3-2-案例实操" class="headerlink" title="4.3.2  案例实操"></a>4.3.2  案例实操</h5><ol><li>输出该脚本文件名称、输入参数1和输入参数2的值</li></ol><pre class=" language-shell"><code class="language-shell">#!/bin/bashecho "$0 $1 $2"~                                                                                                           sh-5.1# vim parameter.shsh-5.1# bash parameter.shparameter.shsh-5.1# bash parameter.sh banzhangparameter.sh banzhangsh-5.1# bash parameter.sh banzhang lobveparameter.sh banzhang lobvesh-5.1# bash parameter.sh banzhang lobve mmparameter.sh banzhang lobvesh-5.1# vim parameter.sh              ~       </code></pre><h4 id="4-4-特殊变量："><a href="#4-4-特殊变量：" class="headerlink" title="4.4 特殊变量：$#"></a>4.4 特殊变量：$#</h4><h5 id="4-4-1-基本语法"><a href="#4-4-1-基本语法" class="headerlink" title="4.4.1 基本语法"></a>4.4.1 基本语法</h5><p>$# (功能描述： 获取所有输入参数的个数， 常用于循环）</p><pre class=" language-shell"><code class="language-shell">#!/bin/bashecho "$0 $1 $2"echo $#~        ·································sh-5.1# vim parameter.shsh-5.1# lsbanzhang.txt  hadoop101.bahs  hadoop101.sh  helloworld.sh  parameter.shsh-5.1# chmod +x helloworld.shsh-5.1# chmod 777 parameter.shsh-5.1# ./parameter.sh cls xyz 111./parameter.sh cls xyz3sh-5.1#</code></pre><h4 id="4-5-特殊变量：-、"><a href="#4-5-特殊变量：-、" class="headerlink" title="4.5 特殊变量：$*、$@"></a>4.5 特殊变量：$*、$@</h4><p>$* （功能描述： 这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体）</p><p>$@（功能描述： 这个变量也代表命令行中所有的参数， 只不过$@把每个参数区分对待）</p><pre class=" language-shell"><code class="language-shell">#!/bin/bashecho "$0 $1 $2"echo $#echo $*echo $@····························sh-5.1# ./parameter.sh banhh lobe  1111./parameter.sh banhh lobe3banhh lobe 1111banhh lobe 1111</code></pre><h4 id="4-6-特殊变量"><a href="#4-6-特殊变量" class="headerlink" title="4.6 特殊变量$?"></a>4.6 特殊变量$?</h4><p>$? (功能描述： 最后一次执行的命令的返回状态。如果这个变量的值为0表示上个命令执行正确；如果为非零（具体哪个值，由命令自己决定)，证明上一个命令执行不正确了。</p><pre class=" language-shell"><code class="language-shell">证明helloworld脚本 是否正确执行sh-5.1# ./helloworld.shhelloworld shellsh-5.1# echo $?0sh-5.1#</code></pre><h3 id="第5章-运算符"><a href="#第5章-运算符" class="headerlink" title="第5章 运算符"></a>第5章 运算符</h3><h4 id="5-1-基本语法"><a href="#5-1-基本语法" class="headerlink" title="5.1 基本语法"></a>5.1 基本语法</h4><p>“$((运算式))” 或“$[运算式]”</p><p>expr +,- ,\*,/,% 加、减、乘、除，取余</p><p>注意： expr运算符间要有空格</p><ol><li>计算3+2的值</li></ol><pre class=" language-shell"><code class="language-shell">sh-5.1# expr 2 + 35</code></pre><ol start="2"><li>计算3-2 的值</li></ol><pre class=" language-shell"><code class="language-shell">sh-5.1# expr 3 - 21sh-5.1#</code></pre><ol start="3"><li>计算（2+3）*4的值</li></ol><pre class=" language-shell"><code class="language-shell">sh: 1: command not foundsh-5.1# expr 'expr 2 + 3' \* 4expr: non-integer argument采用 $[运算式]方式sh-5.1#  s=$[(2+3)*4]sh-5.1# echo $s20</code></pre><h3 id="第六章-条件判断"><a href="#第六章-条件判断" class="headerlink" title="第六章 条件判断"></a>第六章 条件判断</h3><h4 id="6-1-基本语法"><a href="#6-1-基本语法" class="headerlink" title="6.1 基本语法"></a>6.1 基本语法</h4><p>[ condition ]  （注意 condition 前后要有空格）</p><p>注意： 条件非空即为true， [ atguigu ] 返回true， []返回false</p><h4 id="6-2-常用判断条件"><a href="#6-2-常用判断条件" class="headerlink" title="6.2 常用判断条件"></a>6.2 常用判断条件</h4><ol><li><p>两个整数之间比较</p><p>= 字符串比较</p><p>-lt 小于（less than)                                        -le 小于等于(less equal)</p><p>-eq 等于（equal）                                        -gt 大于 (greater than)</p><p>-ge 大于等于（greater equal）                   -ne 不等于(Not equal)</p></li><li><p>按照文件权限进行判断</p></li></ol><p>​    -r 有读的权限(read)                                            -w 有写的权限(write)</p><p>​    -x 有执行的权限(execute)                </p><ol start="3"><li><p>按照文件类型进行判断</p><p>-f  文件存在 并且是一个常规的文件(file)</p><p>-e 文件存在（existence）                                     -d 文件存在并且是一个目录(directory)</p></li></ol><pre class=" language-shell"><code class="language-shell">23 是否大于等于22sh-5.1# [ 23 -ge 22 ]sh-5.1# echo $?0helloworld.sh 是否具有写权限sh-5.1# [ -w helloworld.sh ]sh-5.1# echo $?0</code></pre><ol start="4"><li>多条件判断(&amp;&amp; 表示前面一条命令执行成功时候，才执行后一条命令， || 表示上一条命令执行失败后，才执行下一条命令)</li></ol><pre class=" language-shell"><code class="language-shell">sh-5.1# [ condition ] && echo OK || echo notokOKsh-5.1# [  ] && echo OK || echo notoknotok</code></pre><h4 id="第七章-流程控制"><a href="#第七章-流程控制" class="headerlink" title="第七章 流程控制"></a>第七章 流程控制</h4><h5 id="7-1-if-判断"><a href="#7-1-if-判断" class="headerlink" title="7.1 if 判断"></a>7.1 if 判断</h5><p>if [ 条件判断式 ]:then</p><p>​     程序</p><p>fi</p><p>或者</p><p>if [ 条件判断式 ]</p><p>​    then</p><p>​            程序</p><p>fi</p><p>注意事项：</p><ol><li>[ 条件判断式 ]， 中括号和条件判断式之间必须有空格</li><li>if 后要有空格</li></ol><pre class=" language-shell"><code class="language-shell">输入一个数字， 如果是1 ， 则输出banzhang zhenshuai， 如果是2，则输出shell mei，如果是其他，则什么也不输出#!/bin/bashif [ $1 -eq 1 ]then        echo "banzhangzhenshuai"elif [ $1 -eq 2 ]then        echo "shell mei"fish-5.1# bash if.shif.sh: line 3: [: -eq: unary operator expectedif.sh: line 7: [: -eq: unary operator expectedsh-5.1# bash if.sh 1banzhangzhenshuaish-5.1# bash if.sh \2shell meish-5.1# bash if.sh 2shell mei</code></pre><h5 id="7-2-case-断句"><a href="#7-2-case-断句" class="headerlink" title="7.2 case 断句"></a>7.2 case 断句</h5><p>case $变量名 in</p><p>“值1”）</p><p>​       如果变量的值等于1，则执行程序1</p><p>   ;;</p><p>“值2”）</p><p>​       如果变量的值等于2，则执行程序2</p><p>   ;;</p><p>…省略其他分支…</p><p>*）</p><p>如果变量的值都不是以上的值，则执行次程序</p><p>;;</p><p>esac</p><p>注意事项：</p><ol><li>case行结尾必须为单词“in” ， 每一个模式匹配必须以右括号“）” 结束。</li><li>双分号“;;”表示命令序列结束，相当于java中的break</li><li>最后的“*）”表示默认模式， 相当于java中的default</li></ol><pre class=" language-shell"><code class="language-shell">输入一个数字，如果是1 则输出bangzag ，如果是2 则输出java，如果是其他则输出python#!/bin/bashcase $1 in1) echo "c++";;2) echo "java";;*) echo "python";;esacsh-5.1# vim case.shsh-5.1# bash case.sh 2case.sh: line 10: syntax error: unexpected end of filesh-5.1# vim case.shsh-5.1# bash case.sh 2javash-5.1# bash case.sh 3pythonsh-5.1# bash case.sh 1c++</code></pre><h5 id="7-3-for循环"><a href="#7-3-for循环" class="headerlink" title="7.3 for循环"></a>7.3 for循环</h5><p>for (( 初始值;循环控制条件;变量变化 ))</p><p>   do</p><p>​        程序</p><p>   done</p><pre class=" language-shell"><code class="language-shell">从1 加到100#!/bin/bashs=0for(( i=0;i<=100;i++ ))do        s=$[$s+$i]doneecho $ssh-5.1# vim for1.shsh-5.1# bash for1.sh5050</code></pre><p>语法2</p><p>for 变量 in 值1 值2 值3…</p><p>do </p><p>​       程序</p><p>done</p><pre class=" language-shell"><code class="language-shell">打印所有输入参数#!/bin/bashfor i in $*do        echo "shell love $i"donefor k in "$*"do                echo "shell love $k"donefor j in "$@"do        echo "shell love $j"donesh-5.1# touch for2.shsh-5.1# vim for2.shsh-5.1# sh for2.sh 1 2 3shell love 1shell love 2shell love 3sh-5.1# sh for2.sh 1 2 3shell love 1shell love 2shell love 3shell love 1 2 3shell love 1shell love 2shell love 3</code></pre><h5 id="7-4-while循环"><a href="#7-4-while循环" class="headerlink" title="7.4 while循环"></a>7.4 while循环</h5><p>while [ 条件判断式 ]</p><p>do</p><p>   程序</p><p>done</p><pre class=" language-shell"><code class="language-shell">从1+到100#!/bin/bashs=0i=1while [ $i -le 100 ]do        s=$[$s + $i]        i=$[$i + 1]doneecho $s~        sh-5.1# bash while.sh5050</code></pre><h4 id="第八章-read-读取控制台输入"><a href="#第八章-read-读取控制台输入" class="headerlink" title="第八章 read 读取控制台输入"></a>第八章 read 读取控制台输入</h4><p>read(选项)(参数)</p><p>选项：</p><p>-p： 指定读取值时的提示符：</p><p>-t :   指定读取值时等待的时间（秒）</p><p>参数</p><p>​       变量：指定读取值得变量名</p><ol><li>提示7s内读取控制台输入的名称</li></ol><pre class=" language-shell"><code class="language-shell">#!/bin/bashread -t 7 -p "Enter your name i 7 seconds " NAMEecho $NAME~          sh-5.1# bash read.sh shellEnter your name i 7 seconds shellshell</code></pre><h4 id="第九章-函数"><a href="#第九章-函数" class="headerlink" title="第九章 函数"></a>第九章 函数</h4><h5 id="9-1-系统函数"><a href="#9-1-系统函数" class="headerlink" title="9.1 系统函数"></a>9.1 系统函数</h5><p>basename基本语法</p><p>basename [string/pathname] [suffix] (功能描述： basename 的命令会删掉所有前缀包括最后一个（’/‘)字符，然后将字符串显示出来</p><p>选项：</p><p>suffix为后缀， 如果suffix被指定了， basenname会将pathname或者string中的suffix去掉。</p><pre class=" language-shell"><code class="language-shell">截取该/homeshell/banzhang.txt路径的文件名称sh-5.1# basename /homeshell/banzhang.txt .txtbanzhang</code></pre><p>dirname   文件绝对路径 ( 功能描述： 从给定的包含绝对路径中取出文件名（非目录的部分)，然后返回剩下的路径)</p><pre class=" language-shell"><code class="language-shell">获取截取该/homeshell/banzhang.txt路径的文件路径sh-5.1# dirname /homeshell/banzhang.txt/homeshell</code></pre><h5 id="9-2-自定义函数"><a href="#9-2-自定义函数" class="headerlink" title="9.2 自定义函数"></a>9.2 自定义函数</h5><p>基本语法</p><p>[ function ] funname[()]</p><p>{</p><p>​Action；</p><p>​[return int;]</p><p>}</p><ol start="2"><li>经验技巧</li></ol><p>2.1 必须在调用地方之前，先声明函数， shell脚本是逐行运行的， 不会像其他语言一样 先编译。</p><p>2.2 函数返回值， 只能通过$?系统变量或得，可以显示加:return 返回，如果不加，将以最后一条命令运行结果作为返回值，return后跟数值n(0-255)</p><pre class=" language-shell"><code class="language-shell">计算两个输入参数的和#!/bin/bashfunction sum(){        s=0;        s=$[$1+$2]        echo $s}read -p "input your paramter1: " P1read -p "input your paramter1: " P2sum $P1 $P2sh-5.1# vim sum.shsh-5.1# bash sum.shinput your paramter1:input your paramter1:sum.sh: line 6: +: syntax error: operand expected (error token is "+")sh-5.1# bash sum.shinput your paramter1: 10input your paramter1: 2030</code></pre><h4 id="第十章-shell工具（重点）"><a href="#第十章-shell工具（重点）" class="headerlink" title="第十章 shell工具（重点）"></a>第十章 shell工具（重点）</h4><h5 id="10-1-cut"><a href="#10-1-cut" class="headerlink" title="10.1 cut"></a>10.1 cut</h5><p>cut的工作就是“剪”， 具体的说就是在文件中负责剪切数据用的。cut命令从文件的每一行剪切字节、字符和字段并将这些值输出</p><ol><li>基本用法</li></ol><p>​     cut[选项参数]  filenames</p><p>​    说明: 默认分割符是制表符</p><ol start="2"><li>选项参数说明</li></ol><p><img src="D:\HEXO\source\images\image-20220710225214935.png" alt="image-20220710225214935"></p><pre class=" language-shell"><code class="language-shell">数据准备sh-5.1# touch cut.txtsh-5.1# vim cut.txtsh-5.1# cat cut.txtdong shengguan zhengwo wola   lalei leish-5.1# cut -d " " -f 1 cut.txtdongguanwolalei在cut文件中切割出guanh-5.1# cat cut.txt | grep guanguan zhengsh-5.1# cat cut.txt | grep guan | cut -d " " -f 1guan选取系统PATH变量值， 第二个“：”开始后的所有路径：sh-5.1# echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binsh-5.1# echo $PATH | cut -d : -f 3-/usr/sbin:/usr/bin:/sbin:/bin切割ifconfig后打印的ip地址失败了。sh-5.1# ifconfig eth0 | grep "inet" | cut -d '' -f 2        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255sh-5.1#</code></pre><p><img src="D:\HEXO\source\images\image-20220710230520164.png" alt="image-20220710230520164"></p><h5 id="10-2-sed"><a href="#10-2-sed" class="headerlink" title="10.2 sed"></a>10.2 sed</h5><p>  sed是一种流编辑器， 它一次处理一行内容， 处理时，吧当前处理的行存储在临时缓存区中， 称为：模式空间，接着用sed命令处理缓冲区中的内容， 处理完成后，把缓冲区的内容送往屏幕， 接着处理下一行， 这样不断重复， 直到文件末尾。文件内容没有改变， 除非你使用重定向存储输出。</p><p>基本用法</p><p>sed[选项参数] “command”  filename</p><p><img src="D:\HEXO\source\images\image-20220710230902184.png" alt="image-20220710230902184"></p><h4 id="10-2-2-实战"><a href="#10-2-2-实战" class="headerlink" title="10.2.2 实战"></a>10.2.2 实战</h4><pre class=" language-shell"><code class="language-shell">将mei nv 这个单词插入到sed.txt 第二行下， 打印sh-5.1# touch sed.txtsh-5.1# vim sed.txtsh-5.1# sed '2a mei nv' sed.txtdong shenot pythonmei nvll llko ok删除文件中包含所有wo的行sh-5.1# sed "/m/e" sed.txtdong shenot pythonll llko ok将sed中wo替换为nish-5.1# sed "s/ot/to/g" sed.txtdong shento pythonll llko ok注意：g表示global ，全部替换将sed中第二行删除并将wo替换为nish-5.1# sed -e "2d" -e "s/to/ot/g" sed.txtdong shenll llko ok</code></pre><h4 id="10-3-awk"><a href="#10-3-awk" class="headerlink" title="10.3 awk"></a>10.3 awk</h4><p>一个强大的文本分析工具， 把文件逐行的读入，以空格为默认分隔符将每行切片， 切开的部分再进分析处理。</p><ol><li>基本用法</li><li>awk [选项参数] ‘pattern1{action1} pattern2{action2} ….’ filename</li><li>pattern: 表示AWK在数据中查找的内容，就是匹配模式</li><li>action:在找到匹配时，所执行的一系列命令</li></ol><p><img src="D:\HEXO\source\images\image-20220710231854660.png" alt="image-20220710231854660"></p><h5 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h5><p>数据准备</p><pre><code>sh-5.1# cp /etc/passwd ./sh-5.1# lsbanzhang.txt  case.sh  cut.txt  for1.sh  for2.sh  hadoop101.bahs  hadoop101.sh  helloworld.sh  if.sh  parameter.sh  passwd  read.sh  sed.txt  sum.sh  while.shsh-5.1# awk -F: '/^root/{print $7}' passwd /bin/bash/bin/bashsh-5.1#</code></pre><ol><li><p>搜索passwd文件以root关键词开头的所有行，并输出该行的第7列</p></li><li><p>搜索passwd文件以root关键词开头的所有行，并输出该行的第7列和第一列，中间以“，” 分隔</p><pre class=" language-shell"><code class="language-shell">sh-5.1# awk -F: '/^root/{print  $1“，”$7}' passwd /bin/bash</code></pre><p>注意只有匹配了pattern的行才会执行action</p></li><li><p>只显示、etc/passwd的第一列和第七列，以逗号分隔，且在所有行前面铁建列名user， shell在最后一行叠加“dahaige , /bin/zuishuai”.</p><pre class=" language-shell"><code class="language-shell">  awk -F: 'BEGIN{print "user,shell"}{print $1","$7} END{print "dahaiuge,/bin/zuishuai"}' passwd</code></pre></li></ol><p>注意LBEGIN在所有数据读取行之前执行， END在所有数据执行完之后执行</p><ol start="4"><li><p>将passwd中的用户id增加数值1并输出</p><pre class=" language-shell"><code class="language-shell">awk -vi1-F: '{print $3+i}' passwd</code></pre></li></ol><h5 id="awk的内置变量"><a href="#awk的内置变量" class="headerlink" title="awk的内置变量"></a>awk的内置变量</h5><p><img src="D:\HEXO\source\images\image-20220710232835635.png" alt="image-20220710232835635"></p><h5 id="实操-1"><a href="#实操-1" class="headerlink" title="实操"></a>实操</h5><ol><li>统计passwd文件名，每行的行号，每行的列数</li></ol><pre class=" language-shell"><code class="language-shell">awk -F: '{print "filename:" FILENAME ", linenumer:" NR ",columns:" NF}' passwd</code></pre><ol start="2"><li><p>切割ip</p><pre class=" language-shell"><code class="language-shell">ifconfig eth0 | grep "inet addr" | awk -F : '{print $2}' | awk -F " " '{print $1}'</code></pre></li><li><p>查询sed.txt中空行所在的行号</p><pre class=" language-shell"><code class="language-shell">awk '/^$/{print NR}' sed.txt</code></pre></li></ol><h4 id="10-4-sort"><a href="#10-4-sort" class="headerlink" title="10.4 sort"></a>10.4 sort</h4><p>sort 命令在LInux里非常游泳，它将文件排序，并将排序结果标准输出</p><p><img src="D:\HEXO\source\images\image-20220711002337565.png" alt="image-20220711002337565"></p><h5 id="实操-2"><a href="#实操-2" class="headerlink" title="实操"></a>实操</h5><ol><li><p>按照“：” 分隔之后排序</p><pre class=" language-shell"><code class="language-shell">sort-t ： -nrk 2 sort.sh</code></pre></li></ol><h4 id="第十一章-企业面试题"><a href="#第十一章-企业面试题" class="headerlink" title="第十一章 企业面试题"></a>第十一章 企业面试题</h4><h5 id="11-1-京东"><a href="#11-1-京东" class="headerlink" title="11.1 京东"></a>11.1 京东</h5><p>问题1 ：使用linux命令查询file1中空行所在的行号</p><p>答案：</p><pre class=" language-shell"><code class="language-shell">awk '/^$/{print NR}' sed.txt</code></pre><p> 问题2： 有文件chengji.txt内容如下：</p><p>张三 40</p><p>李四 50</p><p>王五 60</p><p>使用linux命令计算第二列的和并输出</p><pre><code>cat chenji.TXT| AWK -F " " '{sum+=$2} END{print sum}'</code></pre><h5 id="11-2-搜狐-amp-和讯网"><a href="#11-2-搜狐-amp-和讯网" class="headerlink" title="11.2 搜狐&amp;和讯网"></a>11.2 搜狐&amp;和讯网</h5><p>问题1： shell脚本里如何检查一个文件是否存在，如果不存在该如何处理？</p><pre class=" language-shell"><code class="language-shell">#!/bin/bashif [ -f file.txt ]; then   echo "文件存在！"else   echo "文件不存在！"fi</code></pre><h5 id="11-3-新浪"><a href="#11-3-新浪" class="headerlink" title="11.3 新浪"></a>11.3 新浪</h5><p>问题1： 用shell写一个脚本，对文本中无序的一列数据排序</p><pre class=" language-shell"><code class="language-shell">sort -n  test.txt|awk '{a+=$0;print$0}END{print "SUM-"a}'</code></pre><h5 id="11-4-金和网络"><a href="#11-4-金和网络" class="headerlink" title="11.4 金和网络"></a>11.4 金和网络</h5><p>问题1： 请用shell脚本写出 查找当前文件夹，(/home) 下所有文本文件内容包含有字符“shen”的文件名称</p><pre class=" language-shell"><code class="language-shell">grep -r "shen" /home |cut -d ":" -f 1 <留下文件名></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 工具、shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单应矩阵H求解</title>
      <link href="/2023/01/22/%E5%8D%95%E5%BA%94%E7%9F%A9%E9%98%B5H%E6%B1%82%E8%A7%A3/"/>
      <url>/2023/01/22/%E5%8D%95%E5%BA%94%E7%9F%A9%E9%98%B5H%E6%B1%82%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="单应矩阵H求解"><a href="#单应矩阵H求解" class="headerlink" title="单应矩阵H求解"></a>单应矩阵H求解</h2><p>所需求解的单应矩阵：<br>$$<br>H_{3 \times 3}=\left[\begin{array}{lll}<br>h_{11} &amp; h_{12} &amp; h_{13} \<br>h_{21} &amp; h_{22} &amp; h_{23} \<br>h_{31} &amp; h_{32} &amp; h_{33}<br>\end{array}\right]<br>$$<br>单应变换关系：<br>$$<br>\mathrm{s}\left[\begin{array}{c}<br>x^{\prime} \<br>y^{\prime} \<br>1<br>\end{array}\right]=H\left[\begin{array}{l}<br>x \<br>y \<br>1<br>\end{array}\right]=\left[\begin{array}{lll}<br>h_{11} &amp; h_{12} &amp; h_{13} \<br>h_{21} &amp; h_{22} &amp; h_{23} \<br>h_{31} &amp; h_{32} &amp; h_{33}<br>\end{array}\right]\left[\begin{array}{l}<br>x \<br>y \<br>1<br>\end{array}\right]<br>$$<br>为减少自由度， 令h<sub>33</sub> =1, s为尺度因子。<br>$$<br>h_{31} x+h_{32} y+h_{33}=h_{31} x+h_{32} y+1<br>$$</p><p>$$<br>\begin{aligned}<br>x_{i}^{\prime} &amp;=\frac{h_{11} x_{i}+h_{12} y_{i}+h_{13}}{h_{31} x_{i}+h_{32} y_{i}+h_{33}} \<br>y_{i}^{\prime} &amp;=\frac{h_{21} x_{i}+h_{22} y_{i}+h_{23}}{h_{31} x_{i}+h_{32} y_{i}+h_{33}}<br>\end{aligned}<br>$$</p><p>在图像上取在真实世界构成矩形的顺时针的四个角点。</p><p>(x1,y1),(x2,y2),(x3,y3),(x4,y4)以及构成直角的三个点</p><p>(x5,y5),(x6,y6),(x7,y7), 其中（x6,y6)为直角点</p><p>预设期望变换后的矩形，第一个焦点的位置（x1’,y1’)(x2’,y2’) 设计方程组：</p><p>令（x1，y1) (x2,y2) 变换到预设位置（x1’,y1’)(x2’,y2’)<br>$$<br>\begin{aligned}<br>x_{1}^{\prime} &amp;=\frac{h_{11} x_{1}+h_{12} y_{1}+h_{13}}{h_{31} x_{1}+h_{32} y_{1}+h_{33}} \<br>x_{2}^{\prime} &amp;=\frac{h_{11} x_{2}+h_{12} y_{2}+h_{13}}{h_{31} x_{2}+h_{32} y_{2}+h_{33}} \<br>y_{1}^{\prime} &amp;=\frac{h_{21} x_{1}+h_{22} y_{1}+h_{23}}{h_{31} x_{1}+h_{32} y_{1}+h_{33}} \<br>y_{2}^{\prime} &amp;=\frac{h_{21} x_{2}+h_{22} y_{2}+h_{23}}{h_{31} x_{2}+h_{32} y_{2}+h_{33}}<br>\end{aligned}<br>$$<br>令（x1’,y1’)和(x4’,y4’)构成的直线垂直与（x1’,y1’)(x2’,y2’) 构成的直线<br>$$<br>\frac{y_{2}^{\prime}-y_{1}^{\prime}}{x_{2}^{\prime}-x_{1}^{\prime}} \cdot \frac{y_{4}^{\prime}-y_{1}^{\prime}}{x_{4}^{\prime}-x_{1}^{\prime}}=-1<br>$$<br>令x’4到x1’的距离等于x3’ 到x2’的距离， y4’到y1’的距离等于y3’到y2‘的距离，使得(x4’,y4’)和(x3’,y3’)在（x1’,y1’)和(x2’,y2’) 构成的直线的同一侧， 且结合上一个约束， 使得(x2’,y2’) 和(x3’,y3’)直线平行与（x1’,y1’)和(x4’,y4’) 构成的直线，即(x2’,y2’) 和(x3’,y3’) 垂直与</p><p>（x1’,y1’)和(x2’,y2’) 构成的直线<br>$$<br>\begin{aligned}<br>&amp;x_{4}^{\prime}-x_{3}^{\prime}=x_{1}^{\prime}-x_{2}^{\prime} \<br>&amp;y_{4}^{\prime}-y_{3}^{\prime}=y_{1}^{\prime}-y_{2}^{\prime}<br>\end{aligned}<br>$$<br>令(x5’,y5’) 和(x6’,y6’) 垂直与（x6’,y6’)和(x7’,y7’) 构成的直线<br>$$<br>\frac{y_{5}^{\prime}-y_{6}^{\prime}}{x_{5}^{\prime}-x_{6}^{\prime}} \cdot \frac{y_{7}^{\prime}-y_{6}^{\prime}}{x_{7}^{\prime}-x_{6}^{\prime}}=-1<br>$$<br>联立上述8个方程和h33=1可求出单应矩阵H</p><p>此外为了简化求解， 可使得预设期望的变换后的矩形第一个角点（x1’,y1’)，第二个角点的位置（x2’,y2’)的y1和y2 或者x1和x2 相等， 只需要x3=x2 ,x4=x1 即可以保证垂直关系， 计算将大大简化</p><p>通过多选几组点， 结合RANSAC等算法可进行全局优化。</p><p><img src="D:\HEXO\source_posts\从视频标定到SLAM\image-20220717235918026.png" alt="image-20220717235918026"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 多视几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从视频标定到SLAM</title>
      <link href="/2023/01/22/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E8%A7%86%E8%A7%89SLAM%E5%85%AC%E5%BC%80%E8%AF%BE-%E4%BB%8E%E8%A7%86%E9%A2%91%E6%A0%87%E5%AE%9A%E5%88%B0SLAM/"/>
      <url>/2023/01/22/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E8%A7%86%E8%A7%89SLAM%E5%85%AC%E5%BC%80%E8%AF%BE-%E4%BB%8E%E8%A7%86%E9%A2%91%E6%A0%87%E5%AE%9A%E5%88%B0SLAM/</url>
      
        <content type="html"><![CDATA[<h2 id="浙江大学视觉SLAM公开课-从视频标定到SLAM"><a href="#浙江大学视觉SLAM公开课-从视频标定到SLAM" class="headerlink" title="浙江大学视觉SLAM公开课-从视频标定到SLAM"></a>浙江大学视觉SLAM公开课-从视频标定到SLAM</h2><h3 id="CAMERA"><a href="#CAMERA" class="headerlink" title="CAMERA"></a>CAMERA</h3><p><img src="D:\HEXO\source\images\image-20220720231448867.png" alt="image-20220720231448867"></p><p>Pinhole Camera （针孔摄像）</p><p><img src="D:\HEXO\source\images\image-20220720231603837.png" alt="image-20220720231603837"></p><ul><li>角度 距离消失</li><li>平行不保留，长度不在绝对</li><li>维度压缩，丢失了非常多的信息</li></ul><p><img src="D:\HEXO\source\images\image-20220720231642379.png" alt="image-20220720231642379"></p><p>制作一个相机</p><p><img src="D:\HEXO\source\images\image-20220720231722622.png" alt="image-20220720231722622"></p><p><img src="D:\HEXO\source\images\image-20220720231739458.png" alt="image-20220720231739458"></p><p>如何做一个相机， </p><p><img src="D:\HEXO\source\images\image-20220720231928295.png" alt="image-20220720231928295"></p><p>Shringking the Aperture（收缩光圈）</p><p>孔太小， 曝光时间太少， 孔太小， 光的波长不能被忽略会发生光的干涉现象。</p><p><img src="D:\HEXO\source\images\image-20220720232242050.png" alt="image-20220720232242050"></p><p>镜头的作用是啥呢？</p><p>用凸透镜 把光聚集起来，聚焦起来到一个点上， 曝光时间简短，</p><p><img src="D:\HEXO\source\images\image-20220720232428472.png" alt="image-20220720232428472"></p><p>还是会散开， 镜面的角度有关</p><p><img src="D:\HEXO\source\images\image-20220720232454754.png" alt="image-20220720232454754"></p><p><img src="D:\HEXO\source\images\image-20220720232621407.png" alt="image-20220720232621407"></p><p>只有到镜头固定距离，才能清晰成像。，只有一定范围内才清晰。</p><p><img src="D:\HEXO\source\images\image-20220720232813073.png" alt="image-20220720232813073"></p><p>depth of filed。 光圈的作用</p><p>光圈的速度， 光圈越小， 比较长时间曝光， 光圈越大F = 1/直径 </p><p>filed of view 跟相机的焦距直接相关。</p><p><img src="D:\HEXO\source\images\image-20220720233522832.png" alt="image-20220720233522832"></p><p><img src="D:\HEXO\source\images\image-20220720233848624.png" alt="image-20220720233848624"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SLAM、计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目标检测中的匹配机制</title>
      <link href="/2023/01/22/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%AD%E7%9A%84%E5%8C%B9%E9%85%8D%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/01/22/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%AD%E7%9A%84%E5%8C%B9%E9%85%8D%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="目标检测中的匹配机制"><a href="#目标检测中的匹配机制" class="headerlink" title="目标检测中的匹配机制"></a>目标检测中的匹配机制</h1><h3 id="1-FCOS"><a href="#1-FCOS" class="headerlink" title="1. FCOS"></a>1. FCOS</h3><p>相较于reatinnet  FOs 的正负样本匹配机制会产生更多的正样本</p><h3 id="2-ATSS"><a href="#2-ATSS" class="headerlink" title="2. ATSS"></a>2. ATSS</h3><h4 id="匹配步骤"><a href="#匹配步骤" class="headerlink" title="匹配步骤"></a>匹配步骤</h4><ol><li>计算每个gt box与多尺度输出层 anchor之间的IoU</li><li>计算每个gt box与多尺度输出层anchor中心坐标的L2距离</li><li>遍历层 ， 遍历gt box ，topk(k 默认是9 ）L2 最小距离的anchor， 一共有L层个 L*K, 每个gt</li><li>对于每个gt box， 计算anchor与box之间的（IoU）的（mean， var） 均值和方差，相加之和作为阈值</li><li>对于每个gt box 大于阈值的作为正样本， 其他作为负样本</li><li>若topk过大，导致不在内部， 则过滤掉</li></ol><h3 id="3-OTA-Optimal-Transport-Assignment"><a href="#3-OTA-Optimal-Transport-Assignment" class="headerlink" title="3. OTA(Optimal Transport Assignment)"></a>3. OTA(Optimal Transport Assignment)</h3><h3 id="4-simOTA"><a href="#4-simOTA" class="headerlink" title="4. simOTA"></a>4. simOTA</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>simOTA能够自动分析每个gt、所需要多少正样本</li><li>能自动决定每个gt 从哪个特征图来负责检测</li><li>相比OTA, simOTA更快</li><li>相比于OTA， 避免额外超参数</li></ol><h4 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h4><ol><li>计算正区域</li><li>计算anchor与gt的iou</li><li>在候选区域计算cost</li><li>利用iou确定每个gt的dynamic_k</li><li>gt选取cost最小dynamic_k个anchor正样本， 其余为负</li><li>使用正负样本计算loss</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 目标检测、深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智慧交通项目</title>
      <link href="/2023/01/22/%E6%99%BA%E6%85%A7%E4%BA%A4%E9%80%9A%E9%A1%B9%E7%9B%AE/"/>
      <url>/2023/01/22/%E6%99%BA%E6%85%A7%E4%BA%A4%E9%80%9A%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="智慧交通项目"><a href="#智慧交通项目" class="headerlink" title="智慧交通项目"></a>智慧交通项目</h2><h3 id="1-项目简介"><a href="#1-项目简介" class="headerlink" title="1. 项目简介"></a>1. 项目简介</h3><p><strong>学习目标：</strong></p><ul><li>了解智慧交通项目的架构</li><li>了解智慧交通项目中的模块</li><li>完成智慧交通项目的环境搭建</li></ul><p>主要讲解计算机视觉在交通领域的相关应用， 包括车道线检测、多目标车辆追踪以及流量统计方法</p><ul><li>多目标车辆追踪和计数：SORT方法、匈牙利算法。卡尔曼滤波、虚拟线圈等</li><li>车道线检测：张氏相机校正、仿射变换等。</li></ul><p><img src="D:\HEXO\source\images\image-20220819003607691.png" alt="image-20220819003607691"></p><p>项目的架构</p><ul><li>用户层</li><li>服务层</li><li><img src="D:\HEXO\source\images\image-20220819003735927.png" alt="image-20220819003735927"></li></ul><h3 id="2-环境安装"><a href="#2-环境安装" class="headerlink" title="2. 环境安装"></a>2. 环境安装</h3><p>工具包如下：</p><p>Numpy</p><p>Numba</p><p>Scipy</p><p>h5py</p><p>pandas</p><p>opencv-python</p><p>moviepy</p><p>Filterpy</p><p><strong>安装方法</strong></p><pre class=" language-sh"><code class="language-sh"></code></pre><h3 id="3-车流量检测实现"><a href="#3-车流量检测实现" class="headerlink" title="3.车流量检测实现"></a>3.车流量检测实现</h3><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><ul><li>了解多目标跟跟踪的实现方法</li><li>知道车流量统计的方法</li></ul><hr><p>车流量统计主要有以下几种方式：</p><ul><li>人工统计， 耗时耗力，且统计结果不具有可验证性</li><li>传感器计数， 容易收到外界环境因素干扰</li><li>基于视频的车流量统计， 本项目所使用的方法</li></ul><p>主要包括以下几个步骤：</p><ol><li>使用yolov3模型进行目标检测</li><li>使用sort算法进行目标跟踪， 使用卡尔曼滤波进行目标位置预测，并利用匈牙利算法对比目标的相似度， 完成车辆目标跟踪</li><li>利用虚拟线圈的思想来实现车辆目标的技术，完成车流量的统计。</li></ol><p>项目流程如下图所示：</p><p><img src="D:\HEXO\source\images\image-20220820222005495.png" alt="image-20220820222005495"></p><h4 id="3-0-项目介绍"><a href="#3-0-项目介绍" class="headerlink" title="3.0 项目介绍"></a>3.0 项目介绍</h4><h4 id="3-1-多目标跟踪"><a href="#3-1-多目标跟踪" class="headerlink" title="3.1 多目标跟踪"></a>3.1 多目标跟踪</h4><h5 id="学习目标："><a href="#学习目标：" class="headerlink" title="学习目标："></a>学习目标：</h5><ul><li>了解多目标跟着的常见分类方法</li><li>了解多目标跟踪中常用的运动模型</li><li>知道多目标跟着的常用算法</li></ul><h5 id="1-多目标跟踪分类"><a href="#1-多目标跟踪分类" class="headerlink" title="1. 多目标跟踪分类"></a>1. 多目标跟踪分类</h5><p>多目标跟踪，即MOT，也就是在一段视频中同时跟踪多个目标。MOT主要应用在安防监控和自动驾驶等领域中。</p><p><img src="D:\HEXO\source\images\image-20220820223032905.png" alt="image-20220820223032905"></p><p>多目标跟踪可以看做多变量估计问题， 即给定一个图像序列</p><p><img src="D:\HEXO\source\images\image-20220820223139570.png" alt="image-20220820223139570"></p><p>1.1 初始化方法</p><p>多目标跟踪问题，并不是所有目标都会在第一帧出现，也并不是所有目标都会在出现在每一帧，。那如何对出现的目标进行初始化， 可以作为跟踪算法的分类表针， 常见的初始化方法分为两大类，一个是Detection-based-tracking（DBT），另一个是Detection-free-tracking(DFT)。</p><p><img src="D:\HEXO\source\images\image-20220820223509408.png" alt="image-20220820223509408"></p><p><img src="D:\HEXO\source\images\image-20220820223550971.png" alt="image-20220820223550971"></p><p>1.2 处理模式</p><p>MOT也存在着不同的处理模式， Online和Offline两大类， 其主要区别在于是否用了后续帧信息， 下图形象的解释了Online和offline的区别</p><p><img src="D:\HEXO\source\images\image-20220820223736305.png" alt="image-20220820223736305"></p><ul><li>Online Tracking</li><li>Online Tracking 是对视频帧进行逐帧进行处理， 当前帧的跟踪仅仅利用过去的信息。</li><li>Offline tracking</li></ul><p>不同于Online Tracking， Offline Tracking会利用前后视频帧对当前帧进行目标跟踪， 这种方式只适合视频， 如果应用于摄像头，则会有滞后效应， 通常采用时间窗的方式进行处理，节省内存和加速</p><h5 id="2-运动模型"><a href="#2-运动模型" class="headerlink" title="2. 运动模型"></a>2. 运动模型</h5><p>为了简化多目标跟踪的难度， 引入运动模型类简化求解过程，运动模型捕捉目标的动态行为，它估计目标在未来帧中的潜在位置， 从而减少搜索空间。在大多数情况下， 假设目标在现实中是平缓运动的， 那么图像空间也是如此，对于车辆的运动， 大致可以分为线性和非线性两种运动：</p><ul><li>线性运动： 线性运动是目标最主流的模型，假设目标的运动属性平稳（速度，加速度，位置）</li><li>非线性运动：虽然线性运动模型比较常用， 但由于存在它解决不了的问题，非线性模型随之产生，它可以使tracklets间运动相似度计算得更加准确。</li></ul><h5 id="3-跟踪方法"><a href="#3-跟踪方法" class="headerlink" title="3. 跟踪方法"></a>3. 跟踪方法</h5><p>多目标跟踪基于神经网络的算法， 端到端的算法并不多，主要还在实验室刷榜阶段，模型复杂，速度慢， 效果不好。 主要介绍两种主流的算法：</p><p><img src="D:\HEXO\source\images\image-20220820233546906.png" alt="image-20220820233546906"></p><p>3.1 基于Kalman和KM算法的后端优化算法</p><p>该类算法能达到实时性， 但依赖于检测算法效果摇号，特征区分要好， （输出最终结果的好坏，依赖于较强的检测算法，而基于卡尔曼加匈牙利匹配的跟踪算法作用于能够输出检测目标的id，其次能够保证追踪算法的实时性，这样追踪效果会好，id切换少代表的算法是SORT/deepSort</p><p><img src="D:\HEXO\source\images\image-20220820233921267.png" alt="image-20220820233921267"></p><p>SORT是一种实用的多目标跟踪算法，引入线性速度模型于卡尔曼滤波来进行位置预测，再无合适匹配检测框的情况下，使用运动模型来预测物体的位置。匈牙利算法是一种寻找二分图的最大匹配的算法，在多目标跟踪问题中可以简单理解为寻找前后两帧的若干目标的匹配最优解的一种算法。而卡尔曼滤波可以看做是一种运动模型，用来解决对目标轨迹预测，并使用置信度比较高的跟踪结果进行预测结果的修正。</p><p>多目标跟踪一般接在目标检测后， 在工业界目标检测采用比较多的是yolo检测算法。先实现目标检测网络， 检测的输出结果主要是将检测框的位置信息输入到多目标跟踪算法中。</p><p>3.2 基于多线程的单目标跟踪的多目标跟踪算法</p><p>这类算法特点是跟踪效果很好，因为每一个类的物体都单独分配了一个跟踪器， 但该算法对尺度变换的要求大，参数调试需要合理，同时耗费cpu资源，实时性不高， 代表算法是利用KCF进行目标跟踪。</p><p>多目标跟踪本质上是多个目标同时运动的问题， 所以有提出将单目标跟踪器引入到多目标追踪的问题，为每一个目标分配一个跟踪器。然后检测地使用匹配算法来修正那些跟踪失败或者新出现的目标，代表性的单目标跟踪算法为核相关滤波算法（KCF），在精度核速度上同时达到很高的水平，是当时单目标跟踪最优秀的算法之一，后来的很多算法都是基于此做的改进。</p><p>实际应用过程会为每个目标分配一个KCF跟踪器并采用多线程的方式来组织这些跟踪器，同时因为实际硬件条件的限制，不可能提供强大的计算资源，会采用检测器与跟踪交替策略，由于检测帧率不高， 跟踪效果滞后性， 实用效果不大。</p><p><img src="D:\HEXO\source\images\image-20220820235435060.png" alt="image-20220820235435060"></p><h4 id="3-2-辅助功能"><a href="#3-2-辅助功能" class="headerlink" title="3.2 辅助功能"></a>3.2 辅助功能</h4><hr><p>yolo的数据格式</p><p>iou的详解</p><h4 id="3-3-卡尔曼滤波器"><a href="#3-3-卡尔曼滤波器" class="headerlink" title="3.3 卡尔曼滤波器"></a>3.3 卡尔曼滤波器</h4><h4 id="3-4-卡尔曼滤波器实战"><a href="#3-4-卡尔曼滤波器实战" class="headerlink" title="3.4 卡尔曼滤波器实战"></a>3.4 卡尔曼滤波器实战</h4><h4 id="3-5-目标估计模型-卡尔曼滤波"><a href="#3-5-目标估计模型-卡尔曼滤波" class="headerlink" title="3.5 目标估计模型-卡尔曼滤波"></a>3.5 目标估计模型-卡尔曼滤波</h4><h4 id="3-6-匈牙利算法"><a href="#3-6-匈牙利算法" class="headerlink" title="3.6 匈牙利算法"></a>3.6 匈牙利算法</h4><h4 id="3-7-数据关联"><a href="#3-7-数据关联" class="headerlink" title="3.7 数据关联"></a>3.7 数据关联</h4><h4 id="3-8-SORT-x2F-deepSORT"><a href="#3-8-SORT-x2F-deepSORT" class="headerlink" title="3.8 SORT/deepSORT"></a>3.8 SORT/deepSORT</h4><h4 id="3-9-多目标跟着实现"><a href="#3-9-多目标跟着实现" class="headerlink" title="3.9 多目标跟着实现"></a>3.9 多目标跟着实现</h4><h4 id="3-10-yolo模型"><a href="#3-10-yolo模型" class="headerlink" title="3.10 yolo模型"></a>3.10 yolo模型</h4><h4 id="3-12-基于yolo的目标检测"><a href="#3-12-基于yolo的目标检测" class="headerlink" title="3.12 基于yolo的目标检测"></a>3.12 基于yolo的目标检测</h4><h4 id="3-12-车流量统计"><a href="#3-12-车流量统计" class="headerlink" title="3.12 车流量统计"></a>3.12 车流量统计</h4><h4 id="3-13-视频中的车流量统计"><a href="#3-13-视频中的车流量统计" class="headerlink" title="3.13 视频中的车流量统计"></a>3.13 视频中的车流量统计</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
