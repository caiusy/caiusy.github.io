<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一种基于单应性的多相机行人跟踪算法</title>
      <link href="/2023/01/26/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E5%8D%95%E5%BA%94%E6%80%A7%E7%9A%84%E5%A4%9A%E7%9B%B8%E6%9C%BA%E8%A1%8C%E4%BA%BA%E8%B7%9F%E8%B8%AA%E7%AE%97%E6%B3%95/"/>
      <url>/2023/01/26/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E5%8D%95%E5%BA%94%E6%80%A7%E7%9A%84%E5%A4%9A%E7%9B%B8%E6%9C%BA%E8%A1%8C%E4%BA%BA%E8%B7%9F%E8%B8%AA%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="一种基于单应性的多相机行人跟踪算法"><a href="#一种基于单应性的多相机行人跟踪算法" class="headerlink" title="一种基于单应性的多相机行人跟踪算法"></a>一种基于单应性的多相机行人跟踪算法</h3><h4 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1. 摘要"></a>1. 摘要</h4><p>在一个区域周围安装多个廉价的视频监控摄像头是很容易的。然而，多摄像头跟踪仍然是一个发展中的领域。可以使用多个摄像机生产的监控产品包括摄像机提示、广域交通分析、存在遮挡的跟踪以及现场入口跟踪。</p><p>所有这些产品都需要解决一致的标签问题。这意味着给各种摄像机中真实世界目标的所有投影提供相同的元目标跟踪标签。</p><p>本文介绍了一种多摄像头人群跟踪算法的实现与测试。首先，部分重新实现了形状匹配的单摄像机跟踪算法，以便在测试视频中工作。单摄像头跟踪器的输出是多摄像头跟踪器的输入。该算法找到每个目标的脚特征:对应于目标正下方地面平面上的一个点的像素。视野线被发现并用于创建初始元目标关联。然后，元目标在移动时丢弃一系列标记，并根据这些标记计算单应性。然后，基于同源关系的跟踪器细化元目标列表，并根据需要创建新的元目标。</p><p>测试表明，该算法解决了一致性标记问题，并且在学习过程中只需要很少的边缘事件。基于同源性的匹配器被证明完全克服部分和完全的目标遮挡在一对相机之一。</p><h4 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2 介绍"></a>2 介绍</h4><p>视频监控是一项艰巨的任务。基于计算机视觉领域，它本身只有几十年的历史，视频馈电的自动处理通常需要专门的编码和解码硬件，快速的数字信号处理器，以及大量的存储介质。</p><p>处理多个视频流的需求变得越来越重要。摄像机的价格持续下降，像样的“网络摄像机”售价不到20美元。安装同样便宜且简单。此外，社会因素也有助于监控摄像头的普及。伦敦和波士顿等城市的警察部门，以及购物中心和机场等私人企业，都在利用最近的恐怖主义，为增加视频监控提供理由。在大多数大城市，现在很容易发现摄像机。一些装置甚至自夸使用对近红外或热红外波长敏感的摄像机的微光能力。</p><p>尽管多摄像头监控装置越来越普遍，但很少有算法提取额外的、有意义的多摄像头跟踪信息。第2章将介绍一些在单个视频流中跟踪运动对象的算法。单摄像机跟踪问题的解决方案已经相当完善。然而，多摄像头监控系统需要能够处理多个视频流的算法。</p><h5 id="2-1-动机示例"><a href="#2-1-动机示例" class="headerlink" title="2.1 动机示例"></a>2.1 动机示例</h5><p>摄像机A和摄像机B是不相交的——它们观察世界的不同区域，并不重叠。然而，摄像机A和C部分重叠，摄像机B和C也是如此。两个摄像机同时可以看到任何一个位于较暗重叠区域的物体。</p><p>现在检查这三个摄像机的输出。世界上只有两个人。然而，在这三台相机之间，它们被赋予了四个不同的标签:A-8, B-2, C-4和C-5。给定这些对象标签，我们能找到的最重要的信息是哪些标签指向相同的现实世界对象。这是一致的标签问题。</p><p><img src="/../images/image-20230126002534218-167466393754814.png" alt="image-20230126002534218"></p><p>在一定程度上，人类很擅长解决一致性标签问题。人工监控操作员可以对摄像机在世界上的位置保持一个心理模型，并且即使使用不同的摄像机模式(例如一个RGB摄像机和一个热红外摄像机)，也经常可以匹配摄像机与摄像机的特征。此外，人类在匹配物体方面比计算机做得更好，即使这些物体从不同的角度观察，因此具有不同的外观。然而，使用人类来分析多个视频流并不能很好地扩展，因为一个人一次只能看一个屏幕，即使一个场景可能有许多相关的视图。如果使用多个监视操作员，每个人负责一个特定的区域，那么系统将需要开发控制、目标跟踪、目标切换和可能的操作员不注意的程序。</p><p><img src="/../images/image-20230126002725061.png" alt="image-20230126002725061"></p><p>监视系统的一项重要任务是能够跟踪在监视区域内移动的目标。许多相机可能在任何给定的时间内都在观察目标，但即使只使用少数相机，人类也需要有意识地努力确定这组相机。此外，随着目标的移动，观察目标的摄像机也在不断变化。如果一致的标签问题解决了，计算机知道目标是否应该出现在每个摄像机的视野中，那么计算机就可以自动提示显示目标的正确摄像机组。</p><p>图1.2说明了将多个摄像机视为一组单个摄像机的算法和将摄像机视为更多东西的算法之间的区别。图1.2(a)中的算法则不是这样关心多台摄像机可能拍摄世界的同一部分。第二类算法如图1.2(b)所示，取单个摄像机跟踪器的输出并将其组合。创建了新的监视功能。下面将提到这些多摄像头感知算法所创建的一些功能示例。</p><h5 id="2-2-范围-目标"><a href="#2-2-范围-目标" class="headerlink" title="2.2 范围-目标"></a>2.2 范围-目标</h5><p>本论文涵盖了一种多摄像头监控算法的开发、实现和测试。该算法应具有以下特点：</p><ul><li><p>独立于相机外部参数，即位置和方向。该算法应该能够平稳地处理广泛不同的世界视角。</p></li><li><p>独立于相机的内在参数，即焦距，像素倾斜和主点的位置。市场上有不同的相机，算法应该能够处理多个焦距，分辨率的差异等等。</p></li><li><p>独立于相机模式。该算法应该能够处理任何单摄像头跟踪器的输出。算法不应该依赖于底层的摄像头硬件RGB，近红外，热红外，或其他成像技术。</p></li><li><p>解决一致性标签问题。一个真实世界的目标应该链接到该目标可见的每个摄像机中的一个对象标签</p></li><li><p>对目标遮挡和场景入口的鲁棒性。如果一个目标在场景中间进入监视区域，比如通过一扇门，那么该算法应该正确地解决一致性标签问题。类似地，如果一个目标分裂成两个，比如两个亲密的人走不同的路，算法应该识别并正确标记两个目标。</p></li><li><p>设置简单。不需要相机校准。如果需要，训练应尽可能少地花费时间，并应在正常的现场交通条件下进行。训练应该是自动的，不需要操作员干预。</p></li><li><p>具备摄像提示能力。该算法应该能够确定哪些摄像机应该能够看到给定的目标。</p></li></ul><h5 id="2-3-范围-限制"><a href="#2-3-范围-限制" class="headerlink" title="2.3 范围-限制"></a>2.3 范围-限制</h5><p>算法的范围限制如下:</p><ul><li>追踪行走的人的算法应使用。车辆、动物等各类运动物体不在本文研究范围之内。</li><li>要处理的相机对至少有部分重叠的视野。这就要求操作员在安装硬件和初始化算法时做出初步判断:决定哪些摄像机看到的是世界上相同的部分。</li><li>摄像机应该是静止的。一旦安装，相机的内在和外在参数都应该是固定的。这意味着相机不能安装在平底倾斜炮塔上，或者如果它是，炮塔不能移动。</li><li>摄像机的输出图像将是一个实用的大小。该算法将不包括单像素探测器(例如红外运动探测器，光束破光探测器)。这种限制是必要的，以确保单摄像机跟踪是可能的，而不需要对所选算法进行重大更改。</li><li>帧率将足以让单摄像头跟踪算法正常工作。</li><li>相机应近似常规中心投影相机与基本针孔光学。相机具有极宽的视场视点-鱼眼镜头-或显著未校正的扭曲将不使用。</li><li>最重要的是，目标应该在地面上行走。任何两个摄像机之间的重叠区域不得有明显偏离平面。处理丘陵地区或台阶的代码不包含在本算法中。</li><li>摄像机不得安装在地平面上。这可以防止在场景几何中出现退化的情况，如下文所示</li></ul><h5 id="2-4-对-领域的贡献"><a href="#2-4-对-领域的贡献" class="headerlink" title="2.4 对 领域的贡献"></a>2.4 对 领域的贡献</h5><p>  如上所述，多摄像头视频处理是一个相对较新的领域。算法一直在开发中，还有很多问题有待解决。如果本文开发的算法满足1.2节和1.3节中描述的目标和限制，则可以实现以下场景:</p><ul><li><p>自动提示:感兴趣的目标走进监视区域。</p><p>操作员在一个摄像机中标记目标。当目标在整个区域内移动时，计算机在算法的驱动下，自动显示所有可见目标的视频源。目标可以用颜色一致的“光环”或包围框标记。这让操作员专注于目标的行动，而不是它在世界上相对于每个摄像机的位置。</p></li><li><p>路径分析:一个区域被置于监视之下。该算法不是试图手动匹配人们从一个摄像头到另一个摄像头的路径，而是自动连接人们通过该区域所走的路径。这使得流量分析能够更快、更有效地进行。</p></li><li><p>跟踪遮挡恢复。为了欺骗当前的许多跟踪算法，你可以移动到遮挡物后面(例如建筑支柱或高大的同伙)，改变速度，然后移出遮挡物。遮挡破坏了许多当前的跟踪算法，如果速度变化显著，大多数其他算法就会破坏。只要目标在至少一个摄像机中仍然可见，接下来章节中讨论的算法将从遮挡中恢复，并重新建立一致的跟踪标签</p></li><li><p>现场的入口。该算法应该能够在人们可以从框架中间进入的场景中创建一致的跟踪标签，例如通过电梯或门</p></li></ul><h6 id="2-4-1-具体的贡献"><a href="#2-4-1-具体的贡献" class="headerlink" title="2.4.1 具体的贡献"></a>2.4.1 具体的贡献</h6><p>本文为视频处理领域提供了以下具体贡献:</p><ul><li>一种即使在摄像机明显倾斜时也能找到目标脚的方法</li><li>一种利用目标运动来寻找平面诱导单应性的方法，即使入口和出口在空间上是有限的</li><li>一种具有特定规则的方法，描述如何使用平面诱导单应性来跨多个摄像机创建和维持目标关联</li></ul><p>第三章讨论基础理论，第四章讨论实现细节。试验结果见第5章。</p><h4 id="3-背景"><a href="#3-背景" class="headerlink" title="3. 背景"></a>3. 背景</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 多视几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单应性框架下基于图切的前景分割的多摄像机人物跟踪</title>
      <link href="/2023/01/24/%E5%8D%95%E5%BA%94%E6%80%A7%E6%A1%86%E6%9E%B6%E4%B8%8B%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%88%87%E7%9A%84%E5%89%8D%E6%99%AF%E5%88%86%E5%89%B2%E7%9A%84%E5%A4%9A%E6%91%84%E5%83%8F%E6%9C%BA%E4%BA%BA%E7%89%A9%E8%B7%9F%E8%B8%AA/"/>
      <url>/2023/01/24/%E5%8D%95%E5%BA%94%E6%80%A7%E6%A1%86%E6%9E%B6%E4%B8%8B%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%88%87%E7%9A%84%E5%89%8D%E6%99%AF%E5%88%86%E5%89%B2%E7%9A%84%E5%A4%9A%E6%91%84%E5%83%8F%E6%9C%BA%E4%BA%BA%E7%89%A9%E8%B7%9F%E8%B8%AA/</url>
      
        <content type="html"><![CDATA[<h3 id="单应性框架下基于图切的前景分割的多摄像机人物跟踪"><a href="#单应性框架下基于图切的前景分割的多摄像机人物跟踪" class="headerlink" title="单应性框架下基于图切的前景分割的多摄像机人物跟踪"></a>单应性框架下基于图切的前景分割的多摄像机人物跟踪</h3><blockquote><p>Multi Camera Person Tracking Applying a Graph-Cuts based<br>Foreground Segmentation in a Homography Framework</p></blockquote><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>可靠的目标跟踪是实现自动化视频监控系统的必要前提。由于大多数基于机器学习的目标检测方法需要足够的应用场景数据，前景分割是一种流行的方法来寻找可能感兴趣的区域。这些通常需要一个特定的学习阶段，并随着时间的推移进行适应。在这项工作中，我们将提出一种基于图切割的新方法，它优于大多数标准算法。人们普遍认为，遮挡只能在多摄像机环境中解决。应用多层单应性可以使我们仅应用前景数据就能鲁棒地检测和跟踪目标，从而获得较高的跟踪性能。</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4>]]></content>
      
      
      
        <tags>
            
            <tag> Multi-Camera </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在手术室多相机多行人跟踪和重识别</title>
      <link href="/2023/01/24/%E5%9C%A8%E6%89%8B%E6%9C%AF%E5%AE%A4%E5%A4%9A%E7%9B%B8%E6%9C%BA%E5%A4%9A%E8%A1%8C%E4%BA%BA%E8%B7%9F%E8%B8%AA%E5%92%8C%E9%87%8D%E8%AF%86%E5%88%AB/"/>
      <url>/2023/01/24/%E5%9C%A8%E6%89%8B%E6%9C%AF%E5%AE%A4%E5%A4%9A%E7%9B%B8%E6%9C%BA%E5%A4%9A%E8%A1%8C%E4%BA%BA%E8%B7%9F%E8%B8%AA%E5%92%8C%E9%87%8D%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="在手术室多相机多行人跟踪和重识别"><a href="#在手术室多相机多行人跟踪和重识别" class="headerlink" title="在手术室多相机多行人跟踪和重识别"></a>在手术室多相机多行人跟踪和重识别</h3><blockquote><p>Multi-Camera Multi-Person T racking and Re-Identification in<br>an Operating Room</p></blockquote><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>多摄像头多人(MCMP)跟踪与重识别(ReID)是安全、行人分析等方面的重要任务;然而，大多数研究都集中在室外场景，因为在一个有障碍物的拥挤房间里，处理遮挡和错误识别要复杂得多。此外，在一个框架内完成这两项任务具有挑战性。本文提出了一种基于轨迹的方法，将跟踪和ReID任务集成在一起。首先，每台摄像机捕捉到的所有手术成员的姿势被逐帧检测;然后，利用检测到的姿态来跟踪每个摄像机的所有成员的轨迹;最后，将这些不同摄像机的轨迹聚类，通过所有摄像机重新识别手术室中的成员。与其他MCMP跟踪和ReID方法相比，本文提出的方法主要利用轨迹，将手术室场景中不易识别的纹理特征作为辅助线索。本文还在ReID过程中集成了时间信息，这比当前最先进的框架(逐帧进行ReID)更可靠。此外，我们的框架在部署到新场景之前不需要培训。本文还创建了一个带有实际手术室视频的注释MCMP数据集。实验证明了所提出的基于轨迹的ReID算法的有效性。提出的框架在ReID任务中达到了85.44%的准确率，在本文提出的手术室数据集中优于最先进的框架。</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>在本文中，我们旨在建立一种在手术室内获得可靠的单目人员跟踪和相机间人员ReID结果的方法。与直接用神经网络提取图像特征相比，我们主要通过运动轨迹进行判断，以纹理特征作为辅助线索。因为工作人员的运动遵循一定的规则，他们的轨迹比难以区分的纹理特征更可靠。即使是由于遮挡或人为探测失败导致某摄像头的轨迹被“破坏”，在跨摄像头ReID的步骤中，也可以根据其他摄像头更完整的轨迹将其破坏的轨迹连接起来。相对于在闭塞前后强制连接可能属于同一个人的两条轨迹或其他类型的故障，本方法仅追求更好的单目跟踪性能，可以获得更好、更可靠的整体性能。</p><p>该方法可分为三个步骤:首先，利用训练好的姿态估计神经网络检测每台摄像机捕捉到的每一帧图像中工作人员的姿态;然后筛选出姿态置信度得分高的工作人员，根据每个人脚的图像坐标和预估的图像平面到世界地平面的单应性矩阵，估计和跟踪每个人在手术室中的位置;最后，我们设计了一种聚类算法，重新识别所有摄像机中被检测到的工作人员的轨迹，从而获得手术室中所有工作人员的完整轨迹。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>由于手术室场景的特殊性，我们很难用端到端模型解决跟踪和ReID问题;因此，根据其特点，我们建立了一个包含三个模型的框架，逐步完成整个任务。方法流程如图2所示。利用估计的姿态和边界框分别生成所有摄像机的几段轨迹，然后结合所有摄像机的结果连接并重新识别得到的破碎轨迹。</p><p><img src="/../images/image-20230124220825454-16745703020465.png" alt="image-20230124220825454"></p><h5 id="3-1-姿态估计和检测框"><a href="#3-1-姿态估计和检测框" class="headerlink" title="3.1 姿态估计和检测框"></a>3.1 姿态估计和检测框</h5><p>人体姿态估计的研究在计算机视觉领域已流行多年[27-29]。在本文中，我们使用了一种成熟且流行的姿态估计神经网络AlphaPose[27]。对于每一个被检测到的人，AlphaPose不仅给出一套完整的带有置信度分数的姿态关键点，还给出了整个姿态及其包围框的置信度分数。通过获得的信息，我们能够估计每个手术成员在手术室中的位置，并在后续步骤中提取他们的图像特征。</p><h5 id="3-2-单目跟踪"><a href="#3-2-单目跟踪" class="headerlink" title="3.2 单目跟踪"></a>3.2 单目跟踪</h5><p>因此，受Trackpy[30]的启发，我们设计了一种简洁可靠的方法，在单目跟踪的步骤中利用每个人的位置。首先，从所有检测到的姿态中筛选出可用的姿态，删除那些姿态信心分数小于T11或脚踝信心分数都小于T12的姿态。然后，估计每个筛选出来的手术成员的位置，并将其映射到世界地平面上，我们估计其在图像坐标系中的位置，Cp = (xp, yp)，其两个脚踝坐标在同一帧中，这意味着我们利用一个人的两个脚踝的平均坐标来表示他们的位置:<img src="/../images/image-20230124221312362-16745703216817.png" alt="image-20230124221312362"></p><p>，其中Cla和Cra分别表示左右脚踝的坐标，然后我们将Cp映射到世界地平面上，使用预先估计的摄像机单应性矩阵H: <img src="/../images/image-20230124221340476-16745703326399.png" alt="image-20230124221340476"></p><p>其中(Xp, Yp)表示这个人在地坐标系中的坐标。</p><p>最后，我们逐帧跟踪每个筛选的手术成员，如果他们在当前帧和下一帧的位置距离小于预先设定的阈值T13(人在地坐标系中可以跑的最大距离)，则在下一帧中跟踪他们。此外，为了处理某人的姿势可能在某些帧中丢失或被过滤掉的情况，我们设置了另一个参数T14，称为“记忆帧数”，这意味着我们考虑到一个人可能会丢失几帧，然后再次出现的可能性，我们保留消失的外科成员的跟踪，并在他们最后一次出现后保留他们的id，最多保留一些帧数。通过这种方法，我们获得了每个摄像机的所有手术成员的初始轨迹。</p><h5 id="3-3-相机间重识别"><a href="#3-3-相机间重识别" class="headerlink" title="3.3 相机间重识别"></a>3.3 相机间重识别</h5><p>由于闭塞和一些其他干扰，获得的轨迹将被分成几个段为每个手术成员如上所述。在单目跟踪中，这个问题很难解决。幸运的是，在手术室场景中放置多个摄像机是很方便的，这意味着我们可以通过其他摄像机更完整的轨迹来克服这些挑战。我们引入了基于密度的空间聚类方法(DBSCAN[31])来总结不同摄像机的轨迹，为属于同一人的摄像机分配相同的ID。</p><p>原始DBSCAN的思想非常简洁:它从一个没有访问过的任意核心点开始;检索这个点的e邻域，如果它包含足够多的点，则启动一个集群;否则，这个点被标记为噪声。受此思想启发，我们设计了我们的聚类算法:在原始的DBSCAN中，将核心对象定义为其邻域内的高密度点，基于轨迹的完整性，我们将时间长度(单位:帧)大于T21的轨迹定义为我们的案例中的核心对象;对于核心轨迹p，如果p与另一个轨迹q的平均距离小于T22，且p与q的平均目标框相似度(本文采用直方图相关系数)大于T23，则认为q是p的邻域对象。对于聚类后标记为“噪声”的轨迹，我们根据平均距离和平均包围盒相似度为每个“噪声”轨迹寻找最可能的聚类。此外，为了避免逻辑错误，对应于同一行人并来自同一摄像机的轨迹不应该在时域重叠，因为行人只能在一个摄像机帧中出现一次。最后，我们获得了所有检测到的手术成员和对应的轨迹，每个摄像机的id。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Multi-Camera </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于自定位智能摄像机网络的分布式目标跟踪</title>
      <link href="/2023/01/24/%E5%9F%BA%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%BD%8D%E6%99%BA%E8%83%BD%E6%91%84%E5%83%8F%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA/"/>
      <url>/2023/01/24/%E5%9F%BA%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%BD%8D%E6%99%BA%E8%83%BD%E6%91%84%E5%83%8F%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA/</url>
      
        <content type="html"><![CDATA[<h3 id="基于自定位智能摄像机网络的分布式目标跟踪"><a href="#基于自定位智能摄像机网络的分布式目标跟踪" class="headerlink" title="基于自定位智能摄像机网络的分布式目标跟踪"></a>基于自定位智能摄像机网络的分布式目标跟踪</h3><blockquote><p>Distributed Target Tracking using Self Localizing Smart<br>Camera Networks</p></blockquote><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>针对分布式智能摄像机，提出了一种新的分散目标跟踪方案。该方法建立在分布式定位协议之上，该协议允许智能摄像头节点自动识别具有重叠域的相邻传感器，并建立一个通信图，反映节点如何相互作用以融合网络中的测量。新协议将检测和跟踪问题均匀地分布在整个网络中，以无缝的方式计算传感器的切换。该方法还在网络中的节点之间分配有关被跟踪对象状态的知识。然后，这些信息可以通过分布式查询获得，该查询允许网络参与者订阅他们可能感兴趣的不同类型的事件。所提出的方案已用于使用自定义设计的智能摄像机节点的集合实时跟踪目标。给出了实验结果。</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>嵌入式智能摄像头系统成本的降低和性能的提高使得考虑将其应用于各种监视和跟踪应用程序具有吸引力。在不久的将来，将有可能像部署灯泡一样部署小型、不显眼的智能摄像头，对广阔的区域提供无所不在的覆盖。我们可以想象使用这样一个系统来跟踪机场的乘客，从他们到达路边值机到他们登机的时间。同样地，我们可以使用这样一个系统来监控老人或体弱多病的人在他们家中的活动，以提高他们的护理质量。</p><p>为了实现我们的愿景，一个强大的态势感知感知从分布式摄像机的集合，我们将需要解决分布式传感和跟踪的问题。更具体地说，挑战将是可靠地检测、定位和跟踪目标，因为他们在一个由多个分布式智能摄像机覆盖的扩展区域移动。</p><p>为了部署这些系统，我们需要开发检测和跟踪的方法，这些方法可以分布在多个传感器上，而不需要过多的通信。这些系统必须是可扩展的，以允许部署可能涉及分布在扩展区域的数千个摄像头，并且必须对故障具有健壮性，以便在异步添加或删除单个传感器时，整个系统能够优雅地响应。</p><p>本文描述了一种基于去中心化的智能摄像机网络检测与跟踪的新方法。这种方法建立在先前的自定位工作的基础上，该工作允许智能摄像机自动检测和定位具有重叠字段的其他摄像机节点，并建立反映节点如何相互作用以融合网络中的测量的通信图。我们开发了具有有限通信要求的新型网络协议，允许系统通过网络均匀分布检测和跟踪问题，以无缝的方式计算传感器的切换。</p><h4 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 多视几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>adaptive_pose</title>
      <link href="/2023/01/22/adaptive-pose/"/>
      <url>/2023/01/22/adaptive-pose/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://arxiv.org/pdf/2210.04014.pdf">AdaptivePose++</a> : <a href="https://github.com/buptxyb666/AdaptivePose">github</a></p></blockquote><p><img src="/../images/framework.jpg" alt="img"></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li>z[‘ap’] 虽然输出了，但是没有参与最终的计算， 这个ap更像是网络自己学的一个中间级的过程，这个ap没有监督 能学到像论文的示意么。</li><li>Resample2D的作用是啥，在flownet2中搜到了，但还是不太清楚， 是将不同位置的特征进行融合么。 self.gradient_mul是为了控制ap回传的梯度范围么，这个是经验值吗。</li><li>我之前在centernet中加入oks 替换掉了原来的RegWeightedL1Loss_coco()， 你这是额外加了oks的loss，这没有重复学这个回归信息么， 如果为了加快收敛可不可以先RegWeightedL1Loss_coco()，再oks。我一直很好奇如果是自己的数据集，oks中的sigma一般怎么估计呀。 还有oks 的应该是以绝对位置作为计算吧， 我看代码里好像是相对中心点的偏移。</li></ol><h4 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h4><ol><li>z[‘ap’] 只是用于可视化，没有显示的监督，adaptivepose使用中心特征预测ap偏移，再取出ap位置的特征第二跳偏移，整个两跳path是梯度可回传的，所以相当于隐式监督的。</li><li>Resample2D就是warp操作，通过双线性插值取ap位置特征。self.gradient_mul这块意思跟降低该层的学习率一个意思。</li><li>我这边实验效果 oks+L1 &gt; oks &gt; L1。先RegWeightedL1Loss_coco()，再oks这个操作你可以自己试试。自己的数据集如果是人体关键点你直接按着coco取对应位置的sigma就可以了，sigma跟数据集无关。off_to_pose中将中心坐标加到偏移上。首先认为标注过程符合高斯分布，sigma 跟 scale这俩参数乘积，就是高斯分布的方差，直觉上理解就是对偏差的容忍度，比如同样偏移五个像素，可能对于eye的预测误差就是不可容忍的，对于hip的预测误差是可容忍的，对于large scale是可容忍的，对small scale是不可容忍的。coco上提供的标注，也是脸部关键点的sigma最小，其他的大一些，你可以按着这个思路来估算下你所估计的点的sigma。</li></ol><h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><p><img src="/../images/adaptive-pose/image-20230123160115331.png" alt="image-20230123160115331"></p><p><img src="/../images/adaptive-pose/image-20230123160148686.png" alt="image-20230123160148686"></p><p><img src="/../images/adaptive-pose/image-20230123160203161.png" alt="image-20230123160203161"></p><p><img src="/../images/adaptive-pose/image-20230123160217277.png" alt="image-20230123160217277"></p><p><img src="/../images/adaptive-pose/image-20230123160227108.png" alt="image-20230123160227108"></p>]]></content>
      
      
      
        <tags>
            
            <tag> pose </tag>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20220612讨论</title>
      <link href="/2023/01/22/20220612/"/>
      <url>/2023/01/22/20220612/</url>
      
        <content type="html"><![CDATA[<h3 id="20220612"><a href="#20220612" class="headerlink" title="20220612"></a>20220612</h3><h4 id="用docker例子"><a href="#用docker例子" class="headerlink" title="用docker例子"></a>用docker例子</h4><ul><li>怎么把你的image构建的很好</li><li>容量小，并且满足大部分的应用</li><li>shm怎么配置</li><li>dockrfile怎么写</li><li>挂载怎么做</li><li>gpu怎么选卡</li><li>怎么在容器里联调， 容器出了问题怎么解决</li><li>应用在k8s上有啥问题，需要怎么优化。</li></ul><blockquote><p>每个点都有深度可以做，依据自己的怪话，选择自己的切入点</p></blockquote><h4 id="假如模型都是过拟合，怎么定位这个问题"><a href="#假如模型都是过拟合，怎么定位这个问题" class="headerlink" title="假如模型都是过拟合，怎么定位这个问题"></a>假如模型都是过拟合，怎么定位这个问题</h4><ul><li>请问怎么知道它过拟合的类型</li><li>因为什么过拟合的</li><li>模型原因还是数据原因</li><li>训练策略原因</li><li>还是说提前没有预热</li></ul><blockquote><p>花点时间研究比较底层的东西， 别人为什么这么设计算法</p></blockquote><h4 id="本质例如多类分类多标签分类分割，这些他们的本质是在做什么事"><a href="#本质例如多类分类多标签分类分割，这些他们的本质是在做什么事" class="headerlink" title="本质例如多类分类多标签分类分割，这些他们的本质是在做什么事"></a>本质例如多类分类多标签分类分割，这些他们的本质是在做什么事</h4><ul><li>凸优化大概的一个原理</li><li>最优化函数的一个原理</li><li>最小二乘，偏最小2乘等等一系列的</li></ul><h4 id="找到自己擅长的点。"><a href="#找到自己擅长的点。" class="headerlink" title="找到自己擅长的点。"></a>找到自己擅长的点。</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 研讨 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年工作暂时性总结</title>
      <link href="/2023/01/22/2022%E5%B9%B4%E5%B7%A5%E4%BD%9C%E6%9A%82%E6%97%B6%E6%80%A7%E6%80%BB%E7%BB%93/"/>
      <url>/2023/01/22/2022%E5%B9%B4%E5%B7%A5%E4%BD%9C%E6%9A%82%E6%97%B6%E6%80%A7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="2022年工作暂时性总结"><a href="#2022年工作暂时性总结" class="headerlink" title="2022年工作暂时性总结"></a>2022年工作暂时性总结</h3><h4 id="1-车路协同目标检测项目"><a href="#1-车路协同目标检测项目" class="headerlink" title="1. 车路协同目标检测项目"></a>1. 车路协同目标检测项目</h4><p>参与车路协同 目标检测项目中的开发支持，人机非等指标达到项目要求</p><h4 id="2-多目融合代码开发"><a href="#2-多目融合代码开发" class="headerlink" title="2.多目融合代码开发"></a>2.多目融合代码开发</h4><p>实现多相机目标融合， 相机切换利用位置进行轨迹平滑， 利用瞩目目标过来了雷视徐建目标，确保无重复id输出，以下沙的数据为例子， 标注了一个融合的数据集</p><h4 id="3-路侧停车泊位划线"><a href="#3-路侧停车泊位划线" class="headerlink" title="3. 路侧停车泊位划线"></a>3. 路侧停车泊位划线</h4><p>支持3559a,3519a,ax630 ax620a,sd3403等平台，发测指标P90+ R 90+</p><h4 id="4-全图目标定位和朝向"><a href="#4-全图目标定位和朝向" class="headerlink" title="4.全图目标定位和朝向"></a>4.全图目标定位和朝向</h4><p>朝向：有限的数据集标注(2-3w)，目标高大于1/30，朝向角度误差11°以内，正确率为88.5%，且检测指标浮动在2%以内</p><p>定位：在nx平台上工程化实现，工程耗时由86ms减少到19ms， 指标差异不大，在车顶点、路侧停车数据集以及贴地点伪标签数据上探索了定位不同的实现方式，验证哪些是可行的哪些对参数依赖比较大，减少对人为设定参数的依赖。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RANSAC算法</title>
      <link href="/2023/01/22/RANSAC%E7%AE%97%E6%B3%95/"/>
      <url>/2023/01/22/RANSAC%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="RANSAC算法"><a href="#RANSAC算法" class="headerlink" title="RANSAC算法"></a>RANSAC算法</h3><hr><p><strong>RANSAC</strong>(<strong>RA</strong>ndom <strong>SA</strong>mple <strong>C</strong>onsensus,随机采样一致)算法</p><hr><p><strong>RANSAC</strong>(<strong>RA</strong>ndom <strong>SA</strong>mple <strong>C</strong>onsensus,随机采样一致)算法是从一组含有“外点”(outliers)的数据中正确估计数学模型参数的迭代算法。“外点”一般指的的数据中的噪声，比如说匹配中的误匹配和估计曲线中的离群点。所以，RANSAC也是一种“外点”检测算法。RANSAC算法是一种不确定算法，它只能在一种概率下产生结果，并且这个概率会随着迭代次数的增加而加大（之后会解释为什么这个算法是这样的）。RANSAC算最早是由Fischler和Bolles在SRI上提出用来解决LDP(Location Determination Proble)问题的。</p><p>对于RANSAC算法来说一个<strong>基本的假设</strong>就是数据是由“内点”和“外点”组成的。“内点”就是组成模型参数的数据，“外点”就是不适合模型的数据。同时RANSAC假设：在给定一组含有少部分“内点”的数据，存在一个程序可以估计出符合“内点”的模型。</p><h4 id="算法基本思想和流程"><a href="#算法基本思想和流程" class="headerlink" title="算法基本思想和流程"></a>算法基本思想和流程</h4><p>RANSAC是通过反复选择数据集去估计出模型，一直迭代到估计出认为比较好的模型。<br>具体的实现步骤可以分为以下几步：</p><ol><li>选择出可以估计出模型的最小数据集；(对于直线拟合来说就是两个点，对于计算Homography矩阵就是4个点)</li><li>使用这个数据集来计算出数据模型；</li><li>将所有数据带入这个模型，计算出“内点”的数目；(累加在一定误差范围内的适合当前迭代推出模型的数据)</li><li>比较当前模型和之前推出的最好的模型的“内点“的数量，记录最大“内点”数的模型参数和“内点”数；</li><li>重复1-4步，直到迭代结束或者当前模型已经足够好了(“内点数目大于一定数量”)。</li></ol><h4 id="迭代次数推导"><a href="#迭代次数推导" class="headerlink" title="迭代次数推导"></a>迭代次数推导</h4><p>假设“内点”在数据中的占比为 <img src="https://www.zhihu.com/equation?tex=t" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=t=%5Cfrac%7Bn_%7Bi+n+l+i+e+r+s%7D%7D%7Bn_%7Bi+n+l+i+e+r+s%7D+n_%7Bo+u+t+l+i+e+r+s%7D%7D+%5C%5C" alt="[公式]"></p><p>那么我们每次计算模型使用 <img src="https://www.zhihu.com/equation?tex=N" alt="[公式]"> 个点的情况下，选取的点至少有一个外点的情况就是</p><p><img src="https://www.zhihu.com/equation?tex=+1+-+t%5EN+%5C%5C" alt="[公式]"></p><p>也就是说，在迭代 <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]"> 次的情况下， <img src="https://www.zhihu.com/equation?tex=(1-t_n)%5Ek" alt="[公式]"> 就是 <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]"> 次迭代计算模型都至少采样到一个“外点”去计算模型的概率。那么能采样到正确的 <img src="https://www.zhihu.com/equation?tex=N" alt="[公式]"> 个点去计算出正确模型的概率就是</p><p><img src="https://www.zhihu.com/equation?tex=P=1-%5Cleft(1-t%5E%7Bn%7D%5Cright)%5E%7Bk%7D+%5C%5C" alt="[公式]"></p><p>通过上式，可以求得</p><p><img src="https://www.zhihu.com/equation?tex=k=%5Cfrac%7B%5Clog+(1-P)%7D%7B%5Clog+%5Cleft(1-t%5E%7Bn%7D%5Cright)%7D++%5C%5C" alt="[公式]"></p><p>内点”的概率 <img src="https://www.zhihu.com/equation?tex=t" alt="[公式]"> 通常是一个先验值。然后 <img src="https://www.zhihu.com/equation?tex=P" alt="[公式]"> 是我们希望RANSAC得到正确模型的概率。如果事先不知道 <img src="https://www.zhihu.com/equation?tex=t" alt="[公式]"> 的值，可以使用自适应迭代次数的方法。也就是一开始设定一个无穷大的迭代次数，然后每次更新模型参数估计的时候，用当前的“内点”比值当成 <img src="https://www.zhihu.com/equation?tex=t" alt="[公式]"> 来估算出迭代次数。</p><h5 id="用Python实现直线拟合"><a href="#用Python实现直线拟合" class="headerlink" title="用Python实现直线拟合"></a>用Python实现直线拟合</h5><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> random<span class="token keyword">import</span> math<span class="token comment" spellcheck="true"># 数据量。</span>SIZE <span class="token operator">=</span> <span class="token number">50</span><span class="token comment" spellcheck="true"># 产生数据。np.linspace 返回一个一维数组，SIZE指定数组长度。</span><span class="token comment" spellcheck="true"># 数组最小值是0，最大值是10。所有元素间隔相等。</span>X <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> SIZE<span class="token punctuation">)</span>Y <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> X <span class="token operator">+</span> <span class="token number">10</span>fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 画图区域分成1行1列。选择第一块区域。</span>ax1 <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 标题</span>ax1<span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">"RANSAC"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 让散点图的数据更加随机并且添加一些噪声。</span>random_x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>random_y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 添加直线随机噪声</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>SIZE<span class="token punctuation">)</span><span class="token punctuation">:</span>    random_x<span class="token punctuation">.</span>append<span class="token punctuation">(</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     random_y<span class="token punctuation">.</span>append<span class="token punctuation">(</span>Y<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 添加随机噪声</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>SIZE<span class="token punctuation">)</span><span class="token punctuation">:</span>    random_x<span class="token punctuation">.</span>append<span class="token punctuation">(</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    random_y<span class="token punctuation">.</span>append<span class="token punctuation">(</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">)</span>RANDOM_X <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>random_x<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 散点图的横轴。</span>RANDOM_Y <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>random_y<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 散点图的纵轴。</span><span class="token comment" spellcheck="true"># 画散点图。</span>ax1<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>RANDOM_X<span class="token punctuation">,</span> RANDOM_Y<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 横轴名称。</span>ax1<span class="token punctuation">.</span>set_xlabel<span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 纵轴名称。</span>ax1<span class="token punctuation">.</span>set_ylabel<span class="token punctuation">(</span><span class="token string">"y"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用RANSAC算法估算模型</span><span class="token comment" spellcheck="true"># 迭代最大次数，每次得到更好的估计会优化iters的数值</span>iters <span class="token operator">=</span> <span class="token number">100000</span><span class="token comment" spellcheck="true"># 数据和模型之间可接受的差值</span>sigma <span class="token operator">=</span> <span class="token number">0.25</span><span class="token comment" spellcheck="true"># 最好模型的参数估计和内点数目</span>best_a <span class="token operator">=</span> <span class="token number">0</span>best_b <span class="token operator">=</span> <span class="token number">0</span>pretotal <span class="token operator">=</span> <span class="token number">0</span><span class="token comment" spellcheck="true"># 希望的得到正确模型的概率</span>P <span class="token operator">=</span> <span class="token number">0.99</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>iters<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 随机在数据中红选出两个点去求解模型</span>    sample_index <span class="token operator">=</span> random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>range<span class="token punctuation">(</span>SIZE <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>    x_1 <span class="token operator">=</span> RANDOM_X<span class="token punctuation">[</span>sample_index<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    x_2 <span class="token operator">=</span> RANDOM_X<span class="token punctuation">[</span>sample_index<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    y_1 <span class="token operator">=</span> RANDOM_Y<span class="token punctuation">[</span>sample_index<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    y_2 <span class="token operator">=</span> RANDOM_Y<span class="token punctuation">[</span>sample_index<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># y = ax + b 求解出a，b</span>    a <span class="token operator">=</span> <span class="token punctuation">(</span>y_2 <span class="token operator">-</span> y_1<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>x_2 <span class="token operator">-</span> x_1<span class="token punctuation">)</span>    b <span class="token operator">=</span> y_1 <span class="token operator">-</span> a <span class="token operator">*</span> x_1    <span class="token comment" spellcheck="true"># 算出内点数目</span>    total_inlier <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> index <span class="token keyword">in</span> range<span class="token punctuation">(</span>SIZE <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        y_estimate <span class="token operator">=</span> a <span class="token operator">*</span> RANDOM_X<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">+</span> b        <span class="token keyword">if</span> abs<span class="token punctuation">(</span>y_estimate <span class="token operator">-</span> RANDOM_Y<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> sigma<span class="token punctuation">:</span>            total_inlier <span class="token operator">=</span> total_inlier <span class="token operator">+</span> <span class="token number">1</span>    <span class="token comment" spellcheck="true"># 判断当前的模型是否比之前估算的模型好</span>    <span class="token keyword">if</span> total_inlier <span class="token operator">></span> pretotal<span class="token punctuation">:</span>        iters <span class="token operator">=</span> math<span class="token punctuation">.</span>log<span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> P<span class="token punctuation">)</span> <span class="token operator">/</span> math<span class="token punctuation">.</span>log<span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> pow<span class="token punctuation">(</span>total_inlier <span class="token operator">/</span> <span class="token punctuation">(</span>SIZE <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        pretotal <span class="token operator">=</span> total_inlier        best_a <span class="token operator">=</span> a        best_b <span class="token operator">=</span> b    <span class="token comment" spellcheck="true"># 判断是否当前模型已经符合超过一半的点</span>    <span class="token keyword">if</span> total_inlier <span class="token operator">></span> SIZE<span class="token punctuation">:</span>        <span class="token keyword">break</span><span class="token comment" spellcheck="true"># 用我们得到的最佳估计画图</span>Y <span class="token operator">=</span> best_a <span class="token operator">*</span> RANDOM_X <span class="token operator">+</span> best_b<span class="token comment" spellcheck="true"># 直线图</span>ax1<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>RANDOM_X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span>text <span class="token operator">=</span> <span class="token string">"best_a = "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>best_a<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\nbest_b = "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>best_b<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span> text<span class="token punctuation">,</span>         fontdict<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'size'</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">'color'</span><span class="token punctuation">:</span> <span class="token string">'r'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="/./images/image-20220718002303153.png" alt="image-20220718002303153"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单应矩阵H求解</title>
      <link href="/2023/01/22/%E5%8D%95%E5%BA%94%E7%9F%A9%E9%98%B5H%E6%B1%82%E8%A7%A3/"/>
      <url>/2023/01/22/%E5%8D%95%E5%BA%94%E7%9F%A9%E9%98%B5H%E6%B1%82%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="单应矩阵H求解"><a href="#单应矩阵H求解" class="headerlink" title="单应矩阵H求解"></a>单应矩阵H求解</h2><p>所需求解的单应矩阵：<br>$$<br>H_{3 \times 3}=\left[\begin{array}{lll}<br>h_{11} &amp; h_{12} &amp; h_{13} \<br>h_{21} &amp; h_{22} &amp; h_{23} \<br>h_{31} &amp; h_{32} &amp; h_{33}<br>\end{array}\right]<br>$$<br>单应变换关系：<br>$$<br>\mathrm{s}\left[\begin{array}{c}<br>x^{\prime} \<br>y^{\prime} \<br>1<br>\end{array}\right]=H\left[\begin{array}{l}<br>x \<br>y \<br>1<br>\end{array}\right]=\left[\begin{array}{lll}<br>h_{11} &amp; h_{12} &amp; h_{13} \<br>h_{21} &amp; h_{22} &amp; h_{23} \<br>h_{31} &amp; h_{32} &amp; h_{33}<br>\end{array}\right]\left[\begin{array}{l}<br>x \<br>y \<br>1<br>\end{array}\right]<br>$$<br>为减少自由度， 令h<sub>33</sub> =1, s为尺度因子。<br>$$<br>h_{31} x+h_{32} y+h_{33}=h_{31} x+h_{32} y+1<br>$$</p><p>$$<br>\begin{aligned}<br>x_{i}^{\prime} &amp;=\frac{h_{11} x_{i}+h_{12} y_{i}+h_{13}}{h_{31} x_{i}+h_{32} y_{i}+h_{33}} \<br>y_{i}^{\prime} &amp;=\frac{h_{21} x_{i}+h_{22} y_{i}+h_{23}}{h_{31} x_{i}+h_{32} y_{i}+h_{33}}<br>\end{aligned}<br>$$</p><p>在图像上取在真实世界构成矩形的顺时针的四个角点。</p><p>(x1,y1),(x2,y2),(x3,y3),(x4,y4)以及构成直角的三个点</p><p>(x5,y5),(x6,y6),(x7,y7), 其中（x6,y6)为直角点</p><p>预设期望变换后的矩形，第一个焦点的位置（x1’,y1’)(x2’,y2’) 设计方程组：</p><p>令（x1，y1) (x2,y2) 变换到预设位置（x1’,y1’)(x2’,y2’)<br>$$<br>\begin{aligned}<br>x_{1}^{\prime} &amp;=\frac{h_{11} x_{1}+h_{12} y_{1}+h_{13}}{h_{31} x_{1}+h_{32} y_{1}+h_{33}} \<br>x_{2}^{\prime} &amp;=\frac{h_{11} x_{2}+h_{12} y_{2}+h_{13}}{h_{31} x_{2}+h_{32} y_{2}+h_{33}} \<br>y_{1}^{\prime} &amp;=\frac{h_{21} x_{1}+h_{22} y_{1}+h_{23}}{h_{31} x_{1}+h_{32} y_{1}+h_{33}} \<br>y_{2}^{\prime} &amp;=\frac{h_{21} x_{2}+h_{22} y_{2}+h_{23}}{h_{31} x_{2}+h_{32} y_{2}+h_{33}}<br>\end{aligned}<br>$$<br>令（x1’,y1’)和(x4’,y4’)构成的直线垂直与（x1’,y1’)(x2’,y2’) 构成的直线<br>$$<br>\frac{y_{2}^{\prime}-y_{1}^{\prime}}{x_{2}^{\prime}-x_{1}^{\prime}} \cdot \frac{y_{4}^{\prime}-y_{1}^{\prime}}{x_{4}^{\prime}-x_{1}^{\prime}}=-1<br>$$<br>令x’4到x1’的距离等于x3’ 到x2’的距离， y4’到y1’的距离等于y3’到y2‘的距离，使得(x4’,y4’)和(x3’,y3’)在（x1’,y1’)和(x2’,y2’) 构成的直线的同一侧， 且结合上一个约束， 使得(x2’,y2’) 和(x3’,y3’)直线平行与（x1’,y1’)和(x4’,y4’) 构成的直线，即(x2’,y2’) 和(x3’,y3’) 垂直与</p><p>（x1’,y1’)和(x2’,y2’) 构成的直线<br>$$<br>\begin{aligned}<br>&amp;x_{4}^{\prime}-x_{3}^{\prime}=x_{1}^{\prime}-x_{2}^{\prime} \<br>&amp;y_{4}^{\prime}-y_{3}^{\prime}=y_{1}^{\prime}-y_{2}^{\prime}<br>\end{aligned}<br>$$<br>令(x5’,y5’) 和(x6’,y6’) 垂直与（x6’,y6’)和(x7’,y7’) 构成的直线<br>$$<br>\frac{y_{5}^{\prime}-y_{6}^{\prime}}{x_{5}^{\prime}-x_{6}^{\prime}} \cdot \frac{y_{7}^{\prime}-y_{6}^{\prime}}{x_{7}^{\prime}-x_{6}^{\prime}}=-1<br>$$<br>联立上述8个方程和h33=1可求出单应矩阵H</p><p>此外为了简化求解， 可使得预设期望的变换后的矩形第一个角点（x1’,y1’)，第二个角点的位置（x2’,y2’)的y1和y2 或者x1和x2 相等， 只需要x3=x2 ,x4=x1 即可以保证垂直关系， 计算将大大简化</p><p>通过多选几组点， 结合RANSAC等算法可进行全局优化。</p><p><img src="/.io//HEXO\source_posts\从视频标定到SLAM\image-20220717235918026.png" alt="image-20220717235918026"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 多视几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智慧交通项目</title>
      <link href="/2023/01/22/%E6%99%BA%E6%85%A7%E4%BA%A4%E9%80%9A%E9%A1%B9%E7%9B%AE/"/>
      <url>/2023/01/22/%E6%99%BA%E6%85%A7%E4%BA%A4%E9%80%9A%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="智慧交通项目"><a href="#智慧交通项目" class="headerlink" title="智慧交通项目"></a>智慧交通项目</h2><h3 id="1-项目简介"><a href="#1-项目简介" class="headerlink" title="1. 项目简介"></a>1. 项目简介</h3><p><strong>学习目标：</strong></p><ul><li>了解智慧交通项目的架构</li><li>了解智慧交通项目中的模块</li><li>完成智慧交通项目的环境搭建</li></ul><p>主要讲解计算机视觉在交通领域的相关应用， 包括车道线检测、多目标车辆追踪以及流量统计方法</p><ul><li>多目标车辆追踪和计数：SORT方法、匈牙利算法。卡尔曼滤波、虚拟线圈等</li><li>车道线检测：张氏相机校正、仿射变换等。</li></ul><p><img src="/./images/image-20220819003607691.png" alt="image-20220819003607691"></p><p>项目的架构</p><ul><li>用户层</li><li>服务层</li><li><img src="/./images/image-20220819003735927.png" alt="image-20220819003735927"></li></ul><h3 id="2-环境安装"><a href="#2-环境安装" class="headerlink" title="2. 环境安装"></a>2. 环境安装</h3><p>工具包如下：</p><p>Numpy</p><p>Numba</p><p>Scipy</p><p>h5py</p><p>pandas</p><p>opencv-python</p><p>moviepy</p><p>Filterpy</p><p><strong>安装方法</strong></p><pre class=" language-sh"><code class="language-sh"></code></pre><h3 id="3-车流量检测实现"><a href="#3-车流量检测实现" class="headerlink" title="3.车流量检测实现"></a>3.车流量检测实现</h3><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><ul><li>了解多目标跟跟踪的实现方法</li><li>知道车流量统计的方法</li></ul><hr><p>车流量统计主要有以下几种方式：</p><ul><li>人工统计， 耗时耗力，且统计结果不具有可验证性</li><li>传感器计数， 容易收到外界环境因素干扰</li><li>基于视频的车流量统计， 本项目所使用的方法</li></ul><p>主要包括以下几个步骤：</p><ol><li>使用yolov3模型进行目标检测</li><li>使用sort算法进行目标跟踪， 使用卡尔曼滤波进行目标位置预测，并利用匈牙利算法对比目标的相似度， 完成车辆目标跟踪</li><li>利用虚拟线圈的思想来实现车辆目标的技术，完成车流量的统计。</li></ol><p>项目流程如下图所示：</p><p><img src="/./images/image-20220820222005495.png" alt="image-20220820222005495"></p><h4 id="3-0-项目介绍"><a href="#3-0-项目介绍" class="headerlink" title="3.0 项目介绍"></a>3.0 项目介绍</h4><h4 id="3-1-多目标跟踪"><a href="#3-1-多目标跟踪" class="headerlink" title="3.1 多目标跟踪"></a>3.1 多目标跟踪</h4><h5 id="学习目标："><a href="#学习目标：" class="headerlink" title="学习目标："></a>学习目标：</h5><ul><li>了解多目标跟着的常见分类方法</li><li>了解多目标跟踪中常用的运动模型</li><li>知道多目标跟着的常用算法</li></ul><h5 id="1-多目标跟踪分类"><a href="#1-多目标跟踪分类" class="headerlink" title="1. 多目标跟踪分类"></a>1. 多目标跟踪分类</h5><p>多目标跟踪，即MOT，也就是在一段视频中同时跟踪多个目标。MOT主要应用在安防监控和自动驾驶等领域中。</p><p><img src="/./images/image-20220820223032905.png" alt="image-20220820223032905"></p><p>多目标跟踪可以看做多变量估计问题， 即给定一个图像序列</p><p><img src="/./images/image-20220820223139570.png" alt="image-20220820223139570"></p><p>1.1 初始化方法</p><p>多目标跟踪问题，并不是所有目标都会在第一帧出现，也并不是所有目标都会在出现在每一帧，。那如何对出现的目标进行初始化， 可以作为跟踪算法的分类表针， 常见的初始化方法分为两大类，一个是Detection-based-tracking（DBT），另一个是Detection-free-tracking(DFT)。</p><p><img src="/./images/image-20220820223509408.png" alt="image-20220820223509408"></p><p><img src="/./images/image-20220820223550971.png" alt="image-20220820223550971"></p><p>1.2 处理模式</p><p>MOT也存在着不同的处理模式， Online和Offline两大类， 其主要区别在于是否用了后续帧信息， 下图形象的解释了Online和offline的区别</p><p><img src="/./images/image-20220820223736305.png" alt="image-20220820223736305"></p><ul><li>Online Tracking</li><li>Online Tracking 是对视频帧进行逐帧进行处理， 当前帧的跟踪仅仅利用过去的信息。</li><li>Offline tracking</li></ul><p>不同于Online Tracking， Offline Tracking会利用前后视频帧对当前帧进行目标跟踪， 这种方式只适合视频， 如果应用于摄像头，则会有滞后效应， 通常采用时间窗的方式进行处理，节省内存和加速</p><h5 id="2-运动模型"><a href="#2-运动模型" class="headerlink" title="2. 运动模型"></a>2. 运动模型</h5><p>为了简化多目标跟踪的难度， 引入运动模型类简化求解过程，运动模型捕捉目标的动态行为，它估计目标在未来帧中的潜在位置， 从而减少搜索空间。在大多数情况下， 假设目标在现实中是平缓运动的， 那么图像空间也是如此，对于车辆的运动， 大致可以分为线性和非线性两种运动：</p><ul><li>线性运动： 线性运动是目标最主流的模型，假设目标的运动属性平稳（速度，加速度，位置）</li><li>非线性运动：虽然线性运动模型比较常用， 但由于存在它解决不了的问题，非线性模型随之产生，它可以使tracklets间运动相似度计算得更加准确。</li></ul><h5 id="3-跟踪方法"><a href="#3-跟踪方法" class="headerlink" title="3. 跟踪方法"></a>3. 跟踪方法</h5><p>多目标跟踪基于神经网络的算法， 端到端的算法并不多，主要还在实验室刷榜阶段，模型复杂，速度慢， 效果不好。 主要介绍两种主流的算法：</p><p><img src="/./images/image-20220820233546906.png" alt="image-20220820233546906"></p><p>3.1 基于Kalman和KM算法的后端优化算法</p><p>该类算法能达到实时性， 但依赖于检测算法效果摇号，特征区分要好， （输出最终结果的好坏，依赖于较强的检测算法，而基于卡尔曼加匈牙利匹配的跟踪算法作用于能够输出检测目标的id，其次能够保证追踪算法的实时性，这样追踪效果会好，id切换少代表的算法是SORT/deepSort</p><p><img src="/./images/image-20220820233921267.png" alt="image-20220820233921267"></p><p>SORT是一种实用的多目标跟踪算法，引入线性速度模型于卡尔曼滤波来进行位置预测，再无合适匹配检测框的情况下，使用运动模型来预测物体的位置。匈牙利算法是一种寻找二分图的最大匹配的算法，在多目标跟踪问题中可以简单理解为寻找前后两帧的若干目标的匹配最优解的一种算法。而卡尔曼滤波可以看做是一种运动模型，用来解决对目标轨迹预测，并使用置信度比较高的跟踪结果进行预测结果的修正。</p><p>多目标跟踪一般接在目标检测后， 在工业界目标检测采用比较多的是yolo检测算法。先实现目标检测网络， 检测的输出结果主要是将检测框的位置信息输入到多目标跟踪算法中。</p><p>3.2 基于多线程的单目标跟踪的多目标跟踪算法</p><p>这类算法特点是跟踪效果很好，因为每一个类的物体都单独分配了一个跟踪器， 但该算法对尺度变换的要求大，参数调试需要合理，同时耗费cpu资源，实时性不高， 代表算法是利用KCF进行目标跟踪。</p><p>多目标跟踪本质上是多个目标同时运动的问题， 所以有提出将单目标跟踪器引入到多目标追踪的问题，为每一个目标分配一个跟踪器。然后检测地使用匹配算法来修正那些跟踪失败或者新出现的目标，代表性的单目标跟踪算法为核相关滤波算法（KCF），在精度核速度上同时达到很高的水平，是当时单目标跟踪最优秀的算法之一，后来的很多算法都是基于此做的改进。</p><p>实际应用过程会为每个目标分配一个KCF跟踪器并采用多线程的方式来组织这些跟踪器，同时因为实际硬件条件的限制，不可能提供强大的计算资源，会采用检测器与跟踪交替策略，由于检测帧率不高， 跟踪效果滞后性， 实用效果不大。</p><p><img src="/./images/image-20220820235435060.png" alt="image-20220820235435060"></p><h4 id="3-2-辅助功能"><a href="#3-2-辅助功能" class="headerlink" title="3.2 辅助功能"></a>3.2 辅助功能</h4><hr><p>yolo的数据格式</p><p>iou的详解</p><h4 id="3-3-卡尔曼滤波器"><a href="#3-3-卡尔曼滤波器" class="headerlink" title="3.3 卡尔曼滤波器"></a>3.3 卡尔曼滤波器</h4><h4 id="3-4-卡尔曼滤波器实战"><a href="#3-4-卡尔曼滤波器实战" class="headerlink" title="3.4 卡尔曼滤波器实战"></a>3.4 卡尔曼滤波器实战</h4><h4 id="3-5-目标估计模型-卡尔曼滤波"><a href="#3-5-目标估计模型-卡尔曼滤波" class="headerlink" title="3.5 目标估计模型-卡尔曼滤波"></a>3.5 目标估计模型-卡尔曼滤波</h4><h4 id="3-6-匈牙利算法"><a href="#3-6-匈牙利算法" class="headerlink" title="3.6 匈牙利算法"></a>3.6 匈牙利算法</h4><h4 id="3-7-数据关联"><a href="#3-7-数据关联" class="headerlink" title="3.7 数据关联"></a>3.7 数据关联</h4><h4 id="3-8-SORT-x2F-deepSORT"><a href="#3-8-SORT-x2F-deepSORT" class="headerlink" title="3.8 SORT/deepSORT"></a>3.8 SORT/deepSORT</h4><h4 id="3-9-多目标跟着实现"><a href="#3-9-多目标跟着实现" class="headerlink" title="3.9 多目标跟着实现"></a>3.9 多目标跟着实现</h4><h4 id="3-10-yolo模型"><a href="#3-10-yolo模型" class="headerlink" title="3.10 yolo模型"></a>3.10 yolo模型</h4><h4 id="3-12-基于yolo的目标检测"><a href="#3-12-基于yolo的目标检测" class="headerlink" title="3.12 基于yolo的目标检测"></a>3.12 基于yolo的目标检测</h4><h4 id="3-12-车流量统计"><a href="#3-12-车流量统计" class="headerlink" title="3.12 车流量统计"></a>3.12 车流量统计</h4><h4 id="3-13-视频中的车流量统计"><a href="#3-13-视频中的车流量统计" class="headerlink" title="3.13 视频中的车流量统计"></a>3.13 视频中的车流量统计</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell学习</title>
      <link href="/2023/01/22/shell%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/01/22/shell%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="shell学习"><a href="#shell学习" class="headerlink" title="shell学习"></a>shell学习</h2><h3 id="1-shell概述"><a href="#1-shell概述" class="headerlink" title="1. shell概述"></a>1. shell概述</h3><p>Shell 是一个命令解释器， 用于接收应用程序/用户命令， 然后调用操作系统内核。</p><p><img src="/./images/image-20220710001433868.png" alt="image-20220710001433868"></p><p> shell 还是一个功能相当强大的编程语言， 易编写，易调试，灵活性强。</p><h3 id="2-shell解析器"><a href="#2-shell解析器" class="headerlink" title="2. shell解析器"></a>2. shell解析器</h3><pre class=" language-sh"><code class="language-sh">/bin/sh/bin/bash/usr/bin/bash/bin/rbash/usr/bin/rbash/usr/bin/sh/bin/dash/usr/bin/dash</code></pre><pre class=" language-shel"><code class="language-shel">root@2a63e139ac66:/bin# echo $SHELL/bin/bash</code></pre><p>系统默认的是bash</p><h3 id="3-Shell-脚本入门"><a href="#3-Shell-脚本入门" class="headerlink" title="3. Shell 脚本入门"></a>3. Shell 脚本入门</h3><h4 id="3-1-脚本格式"><a href="#3-1-脚本格式" class="headerlink" title="3.1 脚本格式"></a>3.1 脚本格式</h4><p>脚本以#!/bin/bash 开头（指定解析器） </p><h4 id="3-2-第一个shell脚本：-helloworld"><a href="#3-2-第一个shell脚本：-helloworld" class="headerlink" title="3.2 第一个shell脚本： helloworld"></a>3.2 第一个shell脚本： helloworld</h4><h5 id="3-2-1-需求：-创建一个shell脚本，-输出helloworld"><a href="#3-2-1-需求：-创建一个shell脚本，-输出helloworld" class="headerlink" title="3.2.1 需求： 创建一个shell脚本， 输出helloworld"></a>3.2.1 需求： 创建一个shell脚本， 输出helloworld</h5><pre class=" language-shell"><code class="language-shell">#!/bin/bashecho "helloworld shell"</code></pre><pre class=" language-sh"><code class="language-sh"> cd shelldata# ls# pwd/root/shelldata# touch helloworld.sh# vim helloworld.sh### sh helloworld.shhelloworld shell</code></pre><p>权限不够</p><pre><code># ./ helloworld.sh/bin/sh: 33: ./: Permission denied</code></pre><h5 id="3-2-2-脚本的常用执行方式"><a href="#3-2-2-脚本的常用执行方式" class="headerlink" title="3.2.2 脚本的常用执行方式"></a>3.2.2 脚本的常用执行方式</h5><p>第一种： 采用bash或者sh+脚本的相对路径或者绝对路径（不用赋予脚本+x权限）</p><p>第二种： 采用输入脚本的绝对路径或者相对路径执行脚本（必须具有可执行权限+x）</p><blockquote><p>注意： 第一种执行方法， 本质是bash解析器帮你执行脚本， 所以脚本本身不需要执行权限， 第二种执行方法， 本质是脚本自己执行，所以需要执行权限。</p></blockquote><h4 id="3-3-第二个shell脚本：-多命令处理"><a href="#3-3-第二个shell脚本：-多命令处理" class="headerlink" title="3.3 第二个shell脚本： 多命令处理"></a>3.3 第二个shell脚本： 多命令处理</h4><h5 id="3-3-1-需求："><a href="#3-3-1-需求：" class="headerlink" title="3.3.1 需求："></a>3.3.1 需求：</h5><p>在/home/atguigu/目录下创建一个bangzhang.txt, 在banzhang.txt中增加“I Love  cls”</p><h5 id="3-3-2-案例实操"><a href="#3-3-2-案例实操" class="headerlink" title="3.3.2 案例实操"></a>3.3.2 案例实操</h5><pre class=" language-shell"><code class="language-shell">#!/bin/bashcd /root/shelldata/touch banzhang.txtecho "I Love cls">> banzhang.txt</code></pre><p>结果显示</p><pre class=" language-shell"><code class="language-shell">sh-5.1# cat banzhang.txtI Love clsI Love clssh-5.1# rm banzhang.txtsh-5.1# bash hadoop101.shsh-5.1# cat banzhang.txtI Love clssh-5.1# vim hadoop101.sh</code></pre><h3 id="4-Shell中的变量"><a href="#4-Shell中的变量" class="headerlink" title="4. Shell中的变量"></a>4. Shell中的变量</h3><h4 id="4-1-系统变量"><a href="#4-1-系统变量" class="headerlink" title="4.1 系统变量"></a>4.1 系统变量</h4><h5 id="4-1-1-常用系统变量"><a href="#4-1-1-常用系统变量" class="headerlink" title="4.1.1 常用系统变量"></a>4.1.1 常用系统变量</h5><p>$HOME、$PWD、$SHELL、$USER等</p><h5 id="4-1-2-案例实操"><a href="#4-1-2-案例实操" class="headerlink" title="4.1.2 案例实操"></a>4.1.2 案例实操</h5><p>查看系统变量的值</p><pre class=" language-shell"><code class="language-shell">sh-5.1# echo $HOME/rootsh-5.1# echo $PWD/root/shelldatash-5.1#</code></pre><p>显示当前shell中所有变量</p><pre class=" language-shell"><code class="language-shell">BASH=/bin/shBASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:extquote:force_fignore:globasciiranges:hostcomplete:interactive_comments:progcomp:promptvars:sourcepathBASH_ALIASES=()BASH_ARGC=()BASH_ARGV=()BASH_CMDS=()BASH_LINENO=()BASH_SOURCE=()BASH_VERSINFO=([0]="5" [1]="1" [2]="16" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")BASH_VERSION='5.1.16(1)-release'COLUMNS=177DIRSTACK=()EUID=0GROUPS=()HISTFILE=/root/.bash_historyHISTFILESIZE=500HISTSIZE=500HOME=/rootHOSTNAME=8b25e507bccaHOSTTYPE=x86_64IFS=''LINES=50MACHTYPE=x86_64-pc-linux-gnuMAILCHECK=60OLDPWD=/rootOPTERR=1OPTIND=1OSTYPE=linux-gnuPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binPIPESTATUS=([0]="0")POSIXLY_CORRECT=yPPID=0PS1='\s-\v\$ 'PS2='> 'PS4='+ 'PWD=/root/shelldataSHELL=/bin/bashSHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor:posixSHLVL=1TERM=xtermUID=0_=/root/shelldata</code></pre><h4 id="4-2-自定义变量"><a href="#4-2-自定义变量" class="headerlink" title="4.2 自定义变量"></a>4.2 自定义变量</h4><h5 id="4-2-1-基本语法"><a href="#4-2-1-基本语法" class="headerlink" title="4.2.1 基本语法"></a>4.2.1 基本语法</h5><p>定义变量： 变量=值</p><pre class=" language-shell"><code class="language-shell">sh-5.1# A=1sh-5.1# echo AAsh-5.1# echo $A1</code></pre><p>撤销变量： unset变量</p><pre class=" language-shell"><code class="language-shell">sh-5.1# unset Ash-5.1# echo $Ash-5.1#</code></pre><p>声明一个静态变量： readonly变量， 注意：不能unset</p><pre class=" language-shell"><code class="language-shell">sh-5.1# readonly B=3sh-5.1# echo $B3sh-5.1# unset Bsh: unset: B: cannot unset: readonly variablesh-5.1#</code></pre><h5 id="4-2-2-变量定义规则"><a href="#4-2-2-变量定义规则" class="headerlink" title="4.2.2 变量定义规则"></a>4.2.2 变量定义规则</h5><ol><li>变量名称可以由字母、数字和下划线构成， 但是不能以数字开头， 环境变量名建议大写</li><li>等号两侧不能有空格</li><li>在bash中， 变量默认类型都是字符串类型， 无法直接进行数值运算。</li></ol><pre class=" language-shell"><code class="language-shell">sh-5.1# C=1+1sh-5.1#Display all 505 possibilities? (y or n)sh-5.1# echo $C1+1sh-5.1#</code></pre><ol start="4"><li>变量的值如果有空格，需要用双引号或者单引号括起来。</li></ol><pre class=" language-shell"><code class="language-shell">sh-5.1# D=bangzhang love mmsh: love: command not foundsh-5.1# D='bangzhang love mm'sh-5.1# echo $Dbangzhang love mmsh-5.1#</code></pre><ol start="5"><li>可以把变量提升为全局环境变量， 可供其他shell程序使用</li></ol><p>export 变量名</p><pre class=" language-shell"><code class="language-shell">sh: ./helloworld.sh: Permission deniedsh-5.1# chmod +x helloworld.shsh-5.1# ./helloworld.shhelloworld shellsh-5.1# export Dsh-5.1# ./helloworld.shhelloworld shellbangzhang love mm</code></pre><h4 id="4-3-特殊变量：-n"><a href="#4-3-特殊变量：-n" class="headerlink" title="4.3 特殊变量：$n"></a>4.3 特殊变量：$n</h4><h5 id="4-3-1-基本语法"><a href="#4-3-1-基本语法" class="headerlink" title="4.3.1 基本语法"></a>4.3.1 基本语法</h5><p>$n（功能描述：n为数字，$0代表该脚本名称，$1-$9代表第一到第九个参数， 十以上的参数需用大括号包含，如${10}）</p><h5 id="4-3-2-案例实操"><a href="#4-3-2-案例实操" class="headerlink" title="4.3.2  案例实操"></a>4.3.2  案例实操</h5><ol><li>输出该脚本文件名称、输入参数1和输入参数2的值</li></ol><pre class=" language-shell"><code class="language-shell">#!/bin/bashecho "$0 $1 $2"~                                                                                                           sh-5.1# vim parameter.shsh-5.1# bash parameter.shparameter.shsh-5.1# bash parameter.sh banzhangparameter.sh banzhangsh-5.1# bash parameter.sh banzhang lobveparameter.sh banzhang lobvesh-5.1# bash parameter.sh banzhang lobve mmparameter.sh banzhang lobvesh-5.1# vim parameter.sh              ~       </code></pre><h4 id="4-4-特殊变量："><a href="#4-4-特殊变量：" class="headerlink" title="4.4 特殊变量：$#"></a>4.4 特殊变量：$#</h4><h5 id="4-4-1-基本语法"><a href="#4-4-1-基本语法" class="headerlink" title="4.4.1 基本语法"></a>4.4.1 基本语法</h5><p>$# (功能描述： 获取所有输入参数的个数， 常用于循环）</p><pre class=" language-shell"><code class="language-shell">#!/bin/bashecho "$0 $1 $2"echo $#~        ·································sh-5.1# vim parameter.shsh-5.1# lsbanzhang.txt  hadoop101.bahs  hadoop101.sh  helloworld.sh  parameter.shsh-5.1# chmod +x helloworld.shsh-5.1# chmod 777 parameter.shsh-5.1# ./parameter.sh cls xyz 111./parameter.sh cls xyz3sh-5.1#</code></pre><h4 id="4-5-特殊变量：-、"><a href="#4-5-特殊变量：-、" class="headerlink" title="4.5 特殊变量：$*、$@"></a>4.5 特殊变量：$*、$@</h4><p>$* （功能描述： 这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体）</p><p>$@（功能描述： 这个变量也代表命令行中所有的参数， 只不过$@把每个参数区分对待）</p><pre class=" language-shell"><code class="language-shell">#!/bin/bashecho "$0 $1 $2"echo $#echo $*echo $@····························sh-5.1# ./parameter.sh banhh lobe  1111./parameter.sh banhh lobe3banhh lobe 1111banhh lobe 1111</code></pre><h4 id="4-6-特殊变量"><a href="#4-6-特殊变量" class="headerlink" title="4.6 特殊变量$?"></a>4.6 特殊变量$?</h4><p>$? (功能描述： 最后一次执行的命令的返回状态。如果这个变量的值为0表示上个命令执行正确；如果为非零（具体哪个值，由命令自己决定)，证明上一个命令执行不正确了。</p><pre class=" language-shell"><code class="language-shell">证明helloworld脚本 是否正确执行sh-5.1# ./helloworld.shhelloworld shellsh-5.1# echo $?0sh-5.1#</code></pre><h3 id="第5章-运算符"><a href="#第5章-运算符" class="headerlink" title="第5章 运算符"></a>第5章 运算符</h3><h4 id="5-1-基本语法"><a href="#5-1-基本语法" class="headerlink" title="5.1 基本语法"></a>5.1 基本语法</h4><p>“$((运算式))” 或“$[运算式]”</p><p>expr +,- ,\*,/,% 加、减、乘、除，取余</p><p>注意： expr运算符间要有空格</p><ol><li>计算3+2的值</li></ol><pre class=" language-shell"><code class="language-shell">sh-5.1# expr 2 + 35</code></pre><ol start="2"><li>计算3-2 的值</li></ol><pre class=" language-shell"><code class="language-shell">sh-5.1# expr 3 - 21sh-5.1#</code></pre><ol start="3"><li>计算（2+3）*4的值</li></ol><pre class=" language-shell"><code class="language-shell">sh: 1: command not foundsh-5.1# expr 'expr 2 + 3' \* 4expr: non-integer argument采用 $[运算式]方式sh-5.1#  s=$[(2+3)*4]sh-5.1# echo $s20</code></pre><h3 id="第六章-条件判断"><a href="#第六章-条件判断" class="headerlink" title="第六章 条件判断"></a>第六章 条件判断</h3><h4 id="6-1-基本语法"><a href="#6-1-基本语法" class="headerlink" title="6.1 基本语法"></a>6.1 基本语法</h4><p>[ condition ]  （注意 condition 前后要有空格）</p><p>注意： 条件非空即为true， [ atguigu ] 返回true， []返回false</p><h4 id="6-2-常用判断条件"><a href="#6-2-常用判断条件" class="headerlink" title="6.2 常用判断条件"></a>6.2 常用判断条件</h4><ol><li><p>两个整数之间比较</p><p>= 字符串比较</p><p>-lt 小于（less than)                                        -le 小于等于(less equal)</p><p>-eq 等于（equal）                                        -gt 大于 (greater than)</p><p>-ge 大于等于（greater equal）                   -ne 不等于(Not equal)</p></li><li><p>按照文件权限进行判断</p></li></ol><p>​    -r 有读的权限(read)                                            -w 有写的权限(write)</p><p>​    -x 有执行的权限(execute)                </p><ol start="3"><li><p>按照文件类型进行判断</p><p>-f  文件存在 并且是一个常规的文件(file)</p><p>-e 文件存在（existence）                                     -d 文件存在并且是一个目录(directory)</p></li></ol><pre class=" language-shell"><code class="language-shell">23 是否大于等于22sh-5.1# [ 23 -ge 22 ]sh-5.1# echo $?0helloworld.sh 是否具有写权限sh-5.1# [ -w helloworld.sh ]sh-5.1# echo $?0</code></pre><ol start="4"><li>多条件判断(&amp;&amp; 表示前面一条命令执行成功时候，才执行后一条命令， || 表示上一条命令执行失败后，才执行下一条命令)</li></ol><pre class=" language-shell"><code class="language-shell">sh-5.1# [ condition ] && echo OK || echo notokOKsh-5.1# [  ] && echo OK || echo notoknotok</code></pre><h4 id="第七章-流程控制"><a href="#第七章-流程控制" class="headerlink" title="第七章 流程控制"></a>第七章 流程控制</h4><h5 id="7-1-if-判断"><a href="#7-1-if-判断" class="headerlink" title="7.1 if 判断"></a>7.1 if 判断</h5><p>if [ 条件判断式 ]:then</p><p>​     程序</p><p>fi</p><p>或者</p><p>if [ 条件判断式 ]</p><p>​    then</p><p>​            程序</p><p>fi</p><p>注意事项：</p><ol><li>[ 条件判断式 ]， 中括号和条件判断式之间必须有空格</li><li>if 后要有空格</li></ol><pre class=" language-shell"><code class="language-shell">输入一个数字， 如果是1 ， 则输出banzhang zhenshuai， 如果是2，则输出shell mei，如果是其他，则什么也不输出#!/bin/bashif [ $1 -eq 1 ]then        echo "banzhangzhenshuai"elif [ $1 -eq 2 ]then        echo "shell mei"fish-5.1# bash if.shif.sh: line 3: [: -eq: unary operator expectedif.sh: line 7: [: -eq: unary operator expectedsh-5.1# bash if.sh 1banzhangzhenshuaish-5.1# bash if.sh \2shell meish-5.1# bash if.sh 2shell mei</code></pre><h5 id="7-2-case-断句"><a href="#7-2-case-断句" class="headerlink" title="7.2 case 断句"></a>7.2 case 断句</h5><p>case $变量名 in</p><p>“值1”）</p><p>​       如果变量的值等于1，则执行程序1</p><p>   ;;</p><p>“值2”）</p><p>​       如果变量的值等于2，则执行程序2</p><p>   ;;</p><p>…省略其他分支…</p><p>*）</p><p>如果变量的值都不是以上的值，则执行次程序</p><p>;;</p><p>esac</p><p>注意事项：</p><ol><li>case行结尾必须为单词“in” ， 每一个模式匹配必须以右括号“）” 结束。</li><li>双分号“;;”表示命令序列结束，相当于java中的break</li><li>最后的“*）”表示默认模式， 相当于java中的default</li></ol><pre class=" language-shell"><code class="language-shell">输入一个数字，如果是1 则输出bangzag ，如果是2 则输出java，如果是其他则输出python#!/bin/bashcase $1 in1) echo "c++";;2) echo "java";;*) echo "python";;esacsh-5.1# vim case.shsh-5.1# bash case.sh 2case.sh: line 10: syntax error: unexpected end of filesh-5.1# vim case.shsh-5.1# bash case.sh 2javash-5.1# bash case.sh 3pythonsh-5.1# bash case.sh 1c++</code></pre><h5 id="7-3-for循环"><a href="#7-3-for循环" class="headerlink" title="7.3 for循环"></a>7.3 for循环</h5><p>for (( 初始值;循环控制条件;变量变化 ))</p><p>   do</p><p>​        程序</p><p>   done</p><pre class=" language-shell"><code class="language-shell">从1 加到100#!/bin/bashs=0for(( i=0;i<=100;i++ ))do        s=$[$s+$i]doneecho $ssh-5.1# vim for1.shsh-5.1# bash for1.sh5050</code></pre><p>语法2</p><p>for 变量 in 值1 值2 值3…</p><p>do </p><p>​       程序</p><p>done</p><pre class=" language-shell"><code class="language-shell">打印所有输入参数#!/bin/bashfor i in $*do        echo "shell love $i"donefor k in "$*"do                echo "shell love $k"donefor j in "$@"do        echo "shell love $j"donesh-5.1# touch for2.shsh-5.1# vim for2.shsh-5.1# sh for2.sh 1 2 3shell love 1shell love 2shell love 3sh-5.1# sh for2.sh 1 2 3shell love 1shell love 2shell love 3shell love 1 2 3shell love 1shell love 2shell love 3</code></pre><h5 id="7-4-while循环"><a href="#7-4-while循环" class="headerlink" title="7.4 while循环"></a>7.4 while循环</h5><p>while [ 条件判断式 ]</p><p>do</p><p>   程序</p><p>done</p><pre class=" language-shell"><code class="language-shell">从1+到100#!/bin/bashs=0i=1while [ $i -le 100 ]do        s=$[$s + $i]        i=$[$i + 1]doneecho $s~        sh-5.1# bash while.sh5050</code></pre><h4 id="第八章-read-读取控制台输入"><a href="#第八章-read-读取控制台输入" class="headerlink" title="第八章 read 读取控制台输入"></a>第八章 read 读取控制台输入</h4><p>read(选项)(参数)</p><p>选项：</p><p>-p： 指定读取值时的提示符：</p><p>-t :   指定读取值时等待的时间（秒）</p><p>参数</p><p>​       变量：指定读取值得变量名</p><ol><li>提示7s内读取控制台输入的名称</li></ol><pre class=" language-shell"><code class="language-shell">#!/bin/bashread -t 7 -p "Enter your name i 7 seconds " NAMEecho $NAME~          sh-5.1# bash read.sh shellEnter your name i 7 seconds shellshell</code></pre><h4 id="第九章-函数"><a href="#第九章-函数" class="headerlink" title="第九章 函数"></a>第九章 函数</h4><h5 id="9-1-系统函数"><a href="#9-1-系统函数" class="headerlink" title="9.1 系统函数"></a>9.1 系统函数</h5><p>basename基本语法</p><p>basename [string/pathname] [suffix] (功能描述： basename 的命令会删掉所有前缀包括最后一个（’/‘)字符，然后将字符串显示出来</p><p>选项：</p><p>suffix为后缀， 如果suffix被指定了， basenname会将pathname或者string中的suffix去掉。</p><pre class=" language-shell"><code class="language-shell">截取该/homeshell/banzhang.txt路径的文件名称sh-5.1# basename /homeshell/banzhang.txt .txtbanzhang</code></pre><p>dirname   文件绝对路径 ( 功能描述： 从给定的包含绝对路径中取出文件名（非目录的部分)，然后返回剩下的路径)</p><pre class=" language-shell"><code class="language-shell">获取截取该/homeshell/banzhang.txt路径的文件路径sh-5.1# dirname /homeshell/banzhang.txt/homeshell</code></pre><h5 id="9-2-自定义函数"><a href="#9-2-自定义函数" class="headerlink" title="9.2 自定义函数"></a>9.2 自定义函数</h5><p>基本语法</p><p>[ function ] funname[()]</p><p>{</p><p>​Action；</p><p>​[return int;]</p><p>}</p><ol start="2"><li>经验技巧</li></ol><p>2.1 必须在调用地方之前，先声明函数， shell脚本是逐行运行的， 不会像其他语言一样 先编译。</p><p>2.2 函数返回值， 只能通过$?系统变量或得，可以显示加:return 返回，如果不加，将以最后一条命令运行结果作为返回值，return后跟数值n(0-255)</p><pre class=" language-shell"><code class="language-shell">计算两个输入参数的和#!/bin/bashfunction sum(){        s=0;        s=$[$1+$2]        echo $s}read -p "input your paramter1: " P1read -p "input your paramter1: " P2sum $P1 $P2sh-5.1# vim sum.shsh-5.1# bash sum.shinput your paramter1:input your paramter1:sum.sh: line 6: +: syntax error: operand expected (error token is "+")sh-5.1# bash sum.shinput your paramter1: 10input your paramter1: 2030</code></pre><h4 id="第十章-shell工具（重点）"><a href="#第十章-shell工具（重点）" class="headerlink" title="第十章 shell工具（重点）"></a>第十章 shell工具（重点）</h4><h5 id="10-1-cut"><a href="#10-1-cut" class="headerlink" title="10.1 cut"></a>10.1 cut</h5><p>cut的工作就是“剪”， 具体的说就是在文件中负责剪切数据用的。cut命令从文件的每一行剪切字节、字符和字段并将这些值输出</p><ol><li>基本用法</li></ol><p>​     cut[选项参数]  filenames</p><p>​    说明: 默认分割符是制表符</p><ol start="2"><li>选项参数说明</li></ol><p><img src="/./images/image-20220710225214935.png" alt="image-20220710225214935"></p><pre class=" language-shell"><code class="language-shell">数据准备sh-5.1# touch cut.txtsh-5.1# vim cut.txtsh-5.1# cat cut.txtdong shengguan zhengwo wola   lalei leish-5.1# cut -d " " -f 1 cut.txtdongguanwolalei在cut文件中切割出guanh-5.1# cat cut.txt | grep guanguan zhengsh-5.1# cat cut.txt | grep guan | cut -d " " -f 1guan选取系统PATH变量值， 第二个“：”开始后的所有路径：sh-5.1# echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binsh-5.1# echo $PATH | cut -d : -f 3-/usr/sbin:/usr/bin:/sbin:/bin切割ifconfig后打印的ip地址失败了。sh-5.1# ifconfig eth0 | grep "inet" | cut -d '' -f 2        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255sh-5.1#</code></pre><p><img src="/./images/image-20220710230520164.png" alt="image-20220710230520164"></p><h5 id="10-2-sed"><a href="#10-2-sed" class="headerlink" title="10.2 sed"></a>10.2 sed</h5><p>  sed是一种流编辑器， 它一次处理一行内容， 处理时，吧当前处理的行存储在临时缓存区中， 称为：模式空间，接着用sed命令处理缓冲区中的内容， 处理完成后，把缓冲区的内容送往屏幕， 接着处理下一行， 这样不断重复， 直到文件末尾。文件内容没有改变， 除非你使用重定向存储输出。</p><p>基本用法</p><p>sed[选项参数] “command”  filename</p><p><img src="/./images/image-20220710230902184.png" alt="image-20220710230902184"></p><h4 id="10-2-2-实战"><a href="#10-2-2-实战" class="headerlink" title="10.2.2 实战"></a>10.2.2 实战</h4><pre class=" language-shell"><code class="language-shell">将mei nv 这个单词插入到sed.txt 第二行下， 打印sh-5.1# touch sed.txtsh-5.1# vim sed.txtsh-5.1# sed '2a mei nv' sed.txtdong shenot pythonmei nvll llko ok删除文件中包含所有wo的行sh-5.1# sed "/m/e" sed.txtdong shenot pythonll llko ok将sed中wo替换为nish-5.1# sed "s/ot/to/g" sed.txtdong shento pythonll llko ok注意：g表示global ，全部替换将sed中第二行删除并将wo替换为nish-5.1# sed -e "2d" -e "s/to/ot/g" sed.txtdong shenll llko ok</code></pre><h4 id="10-3-awk"><a href="#10-3-awk" class="headerlink" title="10.3 awk"></a>10.3 awk</h4><p>一个强大的文本分析工具， 把文件逐行的读入，以空格为默认分隔符将每行切片， 切开的部分再进分析处理。</p><ol><li>基本用法</li><li>awk [选项参数] ‘pattern1{action1} pattern2{action2} ….’ filename</li><li>pattern: 表示AWK在数据中查找的内容，就是匹配模式</li><li>action:在找到匹配时，所执行的一系列命令</li></ol><p><img src="/./images/image-20220710231854660.png" alt="image-20220710231854660"></p><h5 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h5><p>数据准备</p><pre><code>sh-5.1# cp /etc/passwd ./sh-5.1# lsbanzhang.txt  case.sh  cut.txt  for1.sh  for2.sh  hadoop101.bahs  hadoop101.sh  helloworld.sh  if.sh  parameter.sh  passwd  read.sh  sed.txt  sum.sh  while.shsh-5.1# awk -F: '/^root/{print $7}' passwd /bin/bash/bin/bashsh-5.1#</code></pre><ol><li><p>搜索passwd文件以root关键词开头的所有行，并输出该行的第7列</p></li><li><p>搜索passwd文件以root关键词开头的所有行，并输出该行的第7列和第一列，中间以“，” 分隔</p><pre class=" language-shell"><code class="language-shell">sh-5.1# awk -F: '/^root/{print  $1“，”$7}' passwd /bin/bash</code></pre><p>注意只有匹配了pattern的行才会执行action</p></li><li><p>只显示、etc/passwd的第一列和第七列，以逗号分隔，且在所有行前面铁建列名user， shell在最后一行叠加“dahaige , /bin/zuishuai”.</p><pre class=" language-shell"><code class="language-shell">  awk -F: 'BEGIN{print "user,shell"}{print $1","$7} END{print "dahaiuge,/bin/zuishuai"}' passwd</code></pre></li></ol><p>注意LBEGIN在所有数据读取行之前执行， END在所有数据执行完之后执行</p><ol start="4"><li><p>将passwd中的用户id增加数值1并输出</p><pre class=" language-shell"><code class="language-shell">awk -vi1-F: '{print $3+i}' passwd</code></pre></li></ol><h5 id="awk的内置变量"><a href="#awk的内置变量" class="headerlink" title="awk的内置变量"></a>awk的内置变量</h5><p><img src="/./images/image-20220710232835635.png" alt="image-20220710232835635"></p><h5 id="实操-1"><a href="#实操-1" class="headerlink" title="实操"></a>实操</h5><ol><li>统计passwd文件名，每行的行号，每行的列数</li></ol><pre class=" language-shell"><code class="language-shell">awk -F: '{print "filename:" FILENAME ", linenumer:" NR ",columns:" NF}' passwd</code></pre><ol start="2"><li><p>切割ip</p><pre class=" language-shell"><code class="language-shell">ifconfig eth0 | grep "inet addr" | awk -F : '{print $2}' | awk -F " " '{print $1}'</code></pre></li><li><p>查询sed.txt中空行所在的行号</p><pre class=" language-shell"><code class="language-shell">awk '/^$/{print NR}' sed.txt</code></pre></li></ol><h4 id="10-4-sort"><a href="#10-4-sort" class="headerlink" title="10.4 sort"></a>10.4 sort</h4><p>sort 命令在LInux里非常游泳，它将文件排序，并将排序结果标准输出</p><p><img src="/./images/image-20220711002337565.png" alt="image-20220711002337565"></p><h5 id="实操-2"><a href="#实操-2" class="headerlink" title="实操"></a>实操</h5><ol><li><p>按照“：” 分隔之后排序</p><pre class=" language-shell"><code class="language-shell">sort-t ： -nrk 2 sort.sh</code></pre></li></ol><h4 id="第十一章-企业面试题"><a href="#第十一章-企业面试题" class="headerlink" title="第十一章 企业面试题"></a>第十一章 企业面试题</h4><h5 id="11-1-京东"><a href="#11-1-京东" class="headerlink" title="11.1 京东"></a>11.1 京东</h5><p>问题1 ：使用linux命令查询file1中空行所在的行号</p><p>答案：</p><pre class=" language-shell"><code class="language-shell">awk '/^$/{print NR}' sed.txt</code></pre><p> 问题2： 有文件chengji.txt内容如下：</p><p>张三 40</p><p>李四 50</p><p>王五 60</p><p>使用linux命令计算第二列的和并输出</p><pre><code>cat chenji.TXT| AWK -F " " '{sum+=$2} END{print sum}'</code></pre><h5 id="11-2-搜狐-amp-和讯网"><a href="#11-2-搜狐-amp-和讯网" class="headerlink" title="11.2 搜狐&amp;和讯网"></a>11.2 搜狐&amp;和讯网</h5><p>问题1： shell脚本里如何检查一个文件是否存在，如果不存在该如何处理？</p><pre class=" language-shell"><code class="language-shell">#!/bin/bashif [ -f file.txt ]; then   echo "文件存在！"else   echo "文件不存在！"fi</code></pre><h5 id="11-3-新浪"><a href="#11-3-新浪" class="headerlink" title="11.3 新浪"></a>11.3 新浪</h5><p>问题1： 用shell写一个脚本，对文本中无序的一列数据排序</p><pre class=" language-shell"><code class="language-shell">sort -n  test.txt|awk '{a+=$0;print$0}END{print "SUM-"a}'</code></pre><h5 id="11-4-金和网络"><a href="#11-4-金和网络" class="headerlink" title="11.4 金和网络"></a>11.4 金和网络</h5><p>问题1： 请用shell脚本写出 查找当前文件夹，(/home) 下所有文本文件内容包含有字符“shen”的文件名称</p><pre class=" language-shell"><code class="language-shell">grep -r "shen" /home |cut -d ":" -f 1 <留下文件名></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从视频标定到SLAM</title>
      <link href="/2023/01/22/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E8%A7%86%E8%A7%89SLAM%E5%85%AC%E5%BC%80%E8%AF%BE-%E4%BB%8E%E8%A7%86%E9%A2%91%E6%A0%87%E5%AE%9A%E5%88%B0SLAM/"/>
      <url>/2023/01/22/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E8%A7%86%E8%A7%89SLAM%E5%85%AC%E5%BC%80%E8%AF%BE-%E4%BB%8E%E8%A7%86%E9%A2%91%E6%A0%87%E5%AE%9A%E5%88%B0SLAM/</url>
      
        <content type="html"><![CDATA[<h2 id="浙江大学视觉SLAM公开课-从视频标定到SLAM"><a href="#浙江大学视觉SLAM公开课-从视频标定到SLAM" class="headerlink" title="浙江大学视觉SLAM公开课-从视频标定到SLAM"></a>浙江大学视觉SLAM公开课-从视频标定到SLAM</h2><h3 id="CAMERA"><a href="#CAMERA" class="headerlink" title="CAMERA"></a>CAMERA</h3><p><img src="/./images/image-20220720231448867.png" alt="image-20220720231448867"></p><p>Pinhole Camera （针孔摄像）</p><p><img src="/./images/image-20220720231603837.png" alt="image-20220720231603837"></p><ul><li>角度 距离消失</li><li>平行不保留，长度不在绝对</li><li>维度压缩，丢失了非常多的信息</li></ul><p><img src="/./images/image-20220720231642379.png" alt="image-20220720231642379"></p><p>制作一个相机</p><p><img src="/./images/image-20220720231722622.png" alt="image-20220720231722622"></p><p><img src="/./images/image-20220720231739458.png" alt="image-20220720231739458"></p><p>如何做一个相机， </p><p><img src="/./images/image-20220720231928295.png" alt="image-20220720231928295"></p><p>Shringking the Aperture（收缩光圈）</p><p>孔太小， 曝光时间太少， 孔太小， 光的波长不能被忽略会发生光的干涉现象。</p><p><img src="/./images/image-20220720232242050.png" alt="image-20220720232242050"></p><p>镜头的作用是啥呢？</p><p>用凸透镜 把光聚集起来，聚焦起来到一个点上， 曝光时间简短，</p><p><img src="/./images/image-20220720232428472.png" alt="image-20220720232428472"></p><p>还是会散开， 镜面的角度有关</p><p><img src="/./images/image-20220720232454754.png" alt="image-20220720232454754"></p><p><img src="/./images/image-20220720232621407.png" alt="image-20220720232621407"></p><p>只有到镜头固定距离，才能清晰成像。，只有一定范围内才清晰。</p><p><img src="/./images/image-20220720232813073.png" alt="image-20220720232813073"></p><p>depth of filed。 光圈的作用</p><p>光圈的速度， 光圈越小， 比较长时间曝光， 光圈越大F = 1/直径 </p><p>filed of view 跟相机的焦距直接相关。</p><p><img src="/./images/image-20220720233522832.png" alt="image-20220720233522832"></p><p><img src="/./images/image-20220720233848624.png" alt="image-20220720233848624"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目标检测中的匹配机制</title>
      <link href="/2023/01/22/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%AD%E7%9A%84%E5%8C%B9%E9%85%8D%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/01/22/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%AD%E7%9A%84%E5%8C%B9%E9%85%8D%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="目标检测中的匹配机制"><a href="#目标检测中的匹配机制" class="headerlink" title="目标检测中的匹配机制"></a>目标检测中的匹配机制</h1><h3 id="1-FCOS"><a href="#1-FCOS" class="headerlink" title="1. FCOS"></a>1. FCOS</h3><p>相较于reatinnet  FOs 的正负样本匹配机制会产生更多的正样本</p><h3 id="2-ATSS"><a href="#2-ATSS" class="headerlink" title="2. ATSS"></a>2. ATSS</h3><h4 id="匹配步骤"><a href="#匹配步骤" class="headerlink" title="匹配步骤"></a>匹配步骤</h4><ol><li>计算每个gt box与多尺度输出层 anchor之间的IoU</li><li>计算每个gt box与多尺度输出层anchor中心坐标的L2距离</li><li>遍历层 ， 遍历gt box ，topk(k 默认是9 ）L2 最小距离的anchor， 一共有L层个 L*K, 每个gt</li><li>对于每个gt box， 计算anchor与box之间的（IoU）的（mean， var） 均值和方差，相加之和作为阈值</li><li>对于每个gt box 大于阈值的作为正样本， 其他作为负样本</li><li>若topk过大，导致不在内部， 则过滤掉</li></ol><h3 id="3-OTA-Optimal-Transport-Assignment"><a href="#3-OTA-Optimal-Transport-Assignment" class="headerlink" title="3. OTA(Optimal Transport Assignment)"></a>3. OTA(Optimal Transport Assignment)</h3><h3 id="4-simOTA"><a href="#4-simOTA" class="headerlink" title="4. simOTA"></a>4. simOTA</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>simOTA能够自动分析每个gt、所需要多少正样本</li><li>能自动决定每个gt 从哪个特征图来负责检测</li><li>相比OTA, simOTA更快</li><li>相比于OTA， 避免额外超参数</li></ol><h4 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h4><ol><li>计算正区域</li><li>计算anchor与gt的iou</li><li>在候选区域计算cost</li><li>利用iou确定每个gt的dynamic_k</li><li>gt选取cost最小dynamic_k个anchor正样本， 其余为负</li><li>使用正负样本计算loss</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
