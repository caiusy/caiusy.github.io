---
title: 算法竞赛入门经典第四章
categories: 算法
date: 2019-08-18 00:00:00
tags: 算法
  - c++
---


```cpp
    // t4.cpp : 定义控制台应用程序的入口点。
    //
    #include "stdafx.h"
    //素数判断方法2
    #include<stdio.h>
    #include<stdlib.h>
    #include<time.h>
    #include<math.h>
    #include<string.h>
    #define Max 1000000
    #define maxn 100
    int left, chance; //还需要left位置，错chance之后就会输
    char s[maxn], s2[maxn]; //答案是字符串s, 玩家猜的字母序列是s2
    int win, lose; // win=1 表示已经赢了; lose=1 表示已经输了
    long fac(int n)
    {
    	if (0 == n || 1 == n)
    	{
    		return 1;
    	}
    	else
    	{
    		return fac(n - 1)*n;
    	}
    }
    // 非递归的阶乘方法
    long fact(int n)
    {
    	long iRes = 1;
    	for (int i = 1; i <= n; i++)
    	{
    		iRes *= i;
    	}
    	return iRes;
    }
    int combination(int m, int n)
    {
    	long iRes = fac(n) / (fac(m)*fac(n - m));
    	// long iRes = fact(n) /(fac(m)*fac(n-m));
    	printf_s("%ld %.2lf \n", iRes, (double)clock() / CLOCKS_PER_SEC);
    	return iRes;
    }
    // 刽子手游戏---guess函数
    void guess(char ch)
    {
    	int bad = 1;
    	for (int i = 0; i < strlen(s); i++)
    		if (s[i] == ch) { left--; s[i] = ' '; bad = 0; }
    	if (bad) --chance;
    	if (!chance) lose = 1;
    	if (!left) win = 1;
    }
    int main()
    {
    	/*
    	关键:
    	1 用素数筛选法先预处理，默认刚开始全为素数，然后对素数的倍数标记为非素数，			for(int j = i*i ; j <= 10000 ; j += i){iPrimeArr[j] = 1;}
    	2 通过开根号判断素数时，可以用floor,注意浮点数加上0.5，int iRadical = floor(sqrt(n*1.0) + 0.5);
    	3 可以用assert()对输入的合法性进行校验，assert(n >= 5 && n <= 10000);void assert(int exp),如果表达式的值为0则退出。*/
    	//int sum = 1;
    	//for (int i = 3; i <= Max; i += 2)
    	//{
    	//	//因为偶数除了2 都不是质数
    	//	int j;
    	//	for (j = 2; j <= (int)sqrt(i); j++)//利用上述结论判断
    	//		if (i%j == 0) break;
    	//	if (j > (int)sqrt(i))
    	//		sum++;
    	//}
    	//printf_s("Time used = %0.2f s\n", (double)clock() / CLOCKS_PER_SEC);
    	//printf_s("%d\n", sum);
    	//int a, b;
    	//scanf_s("%d %d", &a, &b);
    	//combination(a, b);
    	//刽子手游戏
    	/*
    	游戏规则是这样的：计算机想一个单词让你猜，你每次可以猜一个字母。 如果单词里有那个字母，所有该字母会显示出来；如果没有那个字母，则计算机会在一幅“刽子手”画上填一笔。 这幅画一共需要7笔就能完成，因此你最多只能错6次。 注意，猜一个已经猜过的字母也算错。
    	在本题中，你的任务是编写一个“裁判”程序，输入单词和玩家的猜测，判断玩家赢了（You win.）、 输了（You lose.）还是放弃了（You chickened out.）。 每组数据包含3行，第1行是游戏编号（-1为输入结束标记），第2行是计算机想的单词，第3行是玩家的猜测。 后两行保证只含小写字母。
    	*/
    	//char ans[21];
    	//char gus[28];
    	//int times, yes;
    	//int chances = 7;
    	//int win = 0;
    	//int lose = 0;
    	//scanf_s("%d", &times);
    	//while (times != -1)
    	//{
    	//	printf_s("Round %d\n", times);
    	//	scanf_s("%s\n %s", ans, gus);
    	//	printf_s("Round %s &s\n", ans, gus);
    	//	yes = 0;
    	//	win = 0, lose = 0, chances = 7;
    	//	for (int i = 0; i < strlen(gus); i++)
    	//	{
    	//		int flag = 0;
    	//		for (int j = 0; j < strlen(ans); j++)
    	//		{
    	//			if (ans[j] == gus[i])
    	//			{
    	//				yes++;
    	//				flag = 1;//找到之后不退出，因为有一个有相同的字母
    	//			}
    	//			if (flag == 0)
    	//			{
    	//				chances--;
    	//			}
    	//			if (chances == 0)
    	//			{
    	//				lose = 1;
    	//				printf_s("You lose.\n");
    	//			}
    	//			else if (yes == strlen(ans))
    	//			{
    	//				win = 1;
    	//				printf_s("You win.\n");
    	//				break;
    	//			}
    	//			if (win != 1 && lose != 1)
    	//			{
    	//				printf("You chickened out.\n");
    	//			}
    	//			scanf_s("%d", &times);
    	//		}
    	//	}
    	//}
    	int rnd;
    	while (scanf_s("%d%s%s", &rnd, &s, &s2) == 3 && rnd != -1)
    	{
    		printf_s("%Round %d\n", rnd);
    		win = lose = 0;
    		left = strlen(s);
    		chance = 7;
    		for (int i = 0; i < strlen(s2); i++)
    		{
    			guess(s2[i]); //猜一个字母
    			if (win || lose) break; //检查状态
    		}
    		//根据结果进行输出
    		if (win) printf_s("You win.\n");
    		else if (lose) printf_s("You lose.\n");
    		else printf_s("You chickened out.\n");
    	}
    	system("pause");
        return 0;
    }
```

