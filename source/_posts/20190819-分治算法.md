---
title: 分治算法
categories: 算法
date: 2019-08-19 00:00:00
tags: 算法
  - c++
---

问题： 给定一组数，要求从中找出第k小的元素。  
分析：  
这里通过快速排序算法来解决次问题。记一趟快速排序后，左子集中的元素个数为nleft，则选择问题，可能是一下几种情况之一： 

  * nleft等于k-1，则枢纽值即为所求； 
  * nleft大于k-1,则继续在左子树中找； 
  * nleft小于k-1,则继续在右子集中找  
C++代码实现
        
        


```cpp
// t5.cpp : 定义控制台应用程序的入口点。
//
#include "stdafx.h"
#include "stdafx.h"
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#include<math.h>
#include<string.h>
int quickSelect(int a[], int l, int r, int k)
{
int p = rand() % (r - l + 1) + l;
int pivot = a[p];
{int t = a[p]; a[p] = a[r]; a[r] = t; }
int i = l,j = r;
while (i < j)
{
while (i < j&&a[i] < pivot) i++;
if (i < j) {
a[j] = a[i];
j--;
}
while (i < j&&a[i] >pivot) j--;
if (i < j) {
a[i] = a[j];
i++;
}
}
a[i] = pivot;
p = i;
if (i - l + 1 == k) return a[i];
// j + 1, right, k - (j - left + 1)1)
if (i - l + 1 < k) return quickSelect(a, i+1, r, k-i+l-1);
else return  quickSelect(a, l, i-1, k);
}
int main()
{
int a[] = { 1,4,54,8,3,7,45,58,27,8,25,26,21,12 };
printf_s("%d\n", quickSelect(a, 0, 14, 6));
system("pause");
return 0;
}
```
  

