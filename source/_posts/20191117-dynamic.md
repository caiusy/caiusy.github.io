---
title: dynamic planning
categories: 算法
date: 2019-11-17 00:00:00
tags: 算法
  - python
---


```python
    arr= [1,2,4,1,7,8,3]
    def rec_opt(arr,i):
        if i == 0:
            return arr[0]
        elif i == 1:
            return max(arr[0],arr[1])
        else:
            A = rec_opt(arr,i-2)+arr[i]
            B = rec_opt(arr,i-1)
        return max(A,B)
    print(rec_opt(arr,6))
```

  
### 递归会产生很多的重叠的子问题，运算规模2^n
    
    

```python
    #非递归的方法
    import numpy as np
    def dp_opt(arr):
        opt = np.zeros(len(arr))
        opt[0] = arr[0]
        opt[1] = max(arr[0], arr[1])
        for i in range(2, len(arr)):
            A = opt[i-2] +arr[i]
            B = opt[i-1]
            opt[i] = max(A,B)
        return opt[len(arr)-1]
    dp_opt(arr)
```

      
    

```python
    arr = [3,34,4,12,5,2]
    def rec_subset(arr, i,s):
        if s == 0:
            return True
        elif i == 0:
            return arr[0] == s
        elif arr[i]>s:
            return rec_subset(arr,i-1,s)
        else:
            A= rec_subset(arr,i-1, s-arr[i])
            B = rec_subset(arr, i-1,s)
            return A or B
    rec_subset(arr, len(arr)-1,9)
    ~
```

      
    

```python
    # 非递归的方法，用二维数组来保存
    def dp_subset(arr,s):
        subset = np.zeros((len(arr),s+1),dtype=bool)
        subset[:,0] = True
        subset[0,:] = Fasle
        subset[0,arr[0]] = True
        for i in range(1,len(arr)):
            for ss in range(1,s+1):
                if arr[i]> ss:
                    subset[i,ss] = subset[i-1,ss]
                else:
                    A= subset(i-1, s-arr[i])
                    B = subset(i-1,s)
                    subset[i,s] = A or B
        r ,c  =subset.shape
        return subset[r-1,c-1]
    rec_subset(arr, len(arr)-1,9)
```

