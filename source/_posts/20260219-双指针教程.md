---
title: 双指针（Two Pointers）Feynman 风格教程
date: 2026-02-19 16:02:46
tags:
  - 算法
---
# 双指针（Two Pointers）— Feynman 风格教程

> 目标：把“两个指针协作”的机制讲清楚，给出可运行的题型模板、具体 I/O 示例，并配合图像理解。

## 1. 核心直觉：两个指针 = 两个同步的“游标”

把数组当成一条直线，两个指针就是两个游标。它们用“局部信息”决定下一步动作，从而减少搜索空间。

**关键机制**：
- **有序信息**（单调性）让我们能“确定方向”。
- **约束信息**（例如目标和、去重规则）让我们能“确定动作”。

图示：

![双指针基本概念](/images/20260219-双指针教程/fig1.png)

![双指针常见类型](/images/20260219-双指针教程/fig2.png)

## 2. 对撞指针：有序数组里的“夹逼”

### 2.1 机制直观
左右指针从两端向中间移动。若当前和太大，右指针左移；太小，左指针右移；刚好命中就返回。

图示：

![对撞指针流程图](/images/20260219-双指针教程/fig3.png)

![对撞指针动画](/images/20260219-双指针教程/gif1.gif)

### 2.2 具体 I/O 示例
**输入**：
- `nums = [2, 5, 8, 10, 15, 18, 22, 25]`（长度 `n=8`）
- `target = 27`

**过程**：
- `left=0 (2), right=7 (25) => sum=27`，命中。

**输出**：
- `return (0, 7)` 或 `return [2, 25]`（依题目要求）

### 2.3 代码模板（Python）
```python
def two_sum_sorted(nums, target):
    left, right = 0, len(nums) - 1
    while left < right:
        s = nums[left] + nums[right]
        if s == target:
            return left, right
        if s > target:
            right -= 1
        else:
            left += 1
    return None
```

### 2.4 复杂度
- 时间：O(n)
- 空间：O(1)

---

## 3. 快慢指针：速度差制造“相遇信息”

### 3.1 机制直观
慢指针每次走一步，快指针每次走两步。
- 如果存在环，快慢一定相遇。
- 相遇后可推导出入环点。

图示：

![快慢指针示意](/images/20260219-双指针教程/fig4.png)

![快慢指针动画](/images/20260219-双指针教程/gif2.gif)

### 3.2 具体 I/O 示例（环检测）
**输入**：
- 链表：`1 -> 2 -> 3 -> 4 -> 5 -> 3 ...`（3 是入环点）

**过程**：
- slow: 1->2->3->4...
- fast: 1->3->5->4...
- 相遇则说明有环。

**输出**：
- `True`（存在环）

### 3.3 代码模板（Python）
```python
def has_cycle(head):
    slow, fast = head, head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

### 3.4 复杂度
- 时间：O(n)
- 空间：O(1)

---

## 4. 同向指针：稳定“过滤 + 写回”

### 4.1 机制直观
两个指针同向移动：
- `fast` 负责扫描
- `slow` 负责写入有效元素

图示：

![去重过程示意](/images/20260219-双指针教程/fig5.png)

### 4.2 具体 I/O 示例（去重）
**输入**：
- `nums = [1,1,2,2,3,4,4,5]`（长度 `8`）

**过程**：
- `slow` 指向最后一个有效位置
- 遇到新值时，写入 `nums[slow+1]`

**输出**：
- 数组前 `k` 位为 `[1,2,3,4,5]`，`k=5`

### 4.3 代码模板（Python）
```python
def remove_duplicates(nums):
    if not nums:
        return 0
    slow = 0
    for fast in range(1, len(nums)):
        if nums[fast] != nums[slow]:
            slow += 1
            nums[slow] = nums[fast]
    return slow + 1
```

### 4.4 复杂度
- 时间：O(n)
- 空间：O(1)

---

## 5. 训练式思维（迁移到“可学习”的直觉）

虽然双指针是算法题，但你可以把它当作一种“闭环决策过程”：

- **输入**：当前指针位置 + 局部值
- **损失**：偏离目标（如 sum-target 的误差）
- **更新**：移动指针（left++/right--/fast++）

这种机制类似一个“有约束的贪心优化”。本质是用局部信息做出最有可能减少误差的动作。

---

## 6. 小结

- 对撞指针：利用有序性，缩小区间
- 快慢指针：利用速度差，制造相遇
- 同向指针：扫描 + 写回，稳定过滤

---

## 7. 费曼总结

一句话：双指针不是技巧堆叠，而是“用两条视线把搜索空间压扁”。

- **先找结构**：数组有序/值域单调/可过滤 ⇒ 才能决定指针移动方向。
- **每步有理由**：指针移动是“减少误差”的动作，不是拍脑袋。
- **写回=压缩信息**：同向指针通过覆盖写回，把“保留什么”变成可验证的过程。
- **遇到新题先问**：我能否用两个游标，把未知区域变成更小的已知区域？
